#function names
#fXXXX: function (e.g. fPhotosynthesis)
#rXXXX: pRocedure (e.g. rUpdateLAI)
###

### definition of functions (which return calculated variables)

fComputePAR<-function(globalradiation, CoefPAR) {
  return(CoefPAR*globalradiation)

}

fComputeTemp<-function(tasmax,tasmin) {
  return(cTemp = (tasmax+tasmin)/2)

}

fFunctionstep<-function(x, x1=NA,x2=NA, x3=NA, x4=NA, y1=NA, y2=NA, y3=NA) {
#fonction en _/~\_
#attention: marche SOIT avec x=vecteur et les params=1 chiffre chacun
#                  SOIT avec x=1 chiffre et les params=vecteurs (ou un chiffre)
#                  SOIT avec x et les éventuels params multiples de même longueur
  df<-data.frame(x, x1, x2, x3, x4, y1, y2, y3) #so that they ar all the same length
  noNA<-apply(df,1, function(x) !any(is.na(x)))
  df$toto<-df$y1 + (df$x-df$x1)*(df$y1-df$y2)/(df$x1-df$x2)
  df[noNA & df$x<df$x1, "toto"]<-df$y1[noNA & df$x<df$x1]
  df[noNA & df$x>df$x2 & df$x<=df$x3, "toto"]<-df$y2[noNA & df$x>df$x2 & df$x<=df$x3]
  df[noNA & df$x>df$x3 & df$x<df$x4, "toto"]<- (df$y2 + (df$x-df$x3)*(df$y3-df$y2)/(df$x4-df$x3))[noNA & df$x>df$x3 & df$x<df$x4]
  df[noNA & df$x>=df$x4, "toto"]<-df[noNA & df$x>=df$x4, "y3"]
  df[!noNA, "toto"]<-NA
  return(df$toto)
}

fComputeDailyVernalization<-function(cCrownTemp,TbaseVernalization,Topt1Vernalization,Topt2Vernalization,TstopVernalization) {
  return(fFunctionstep(x=cCrownTemp, x1=TbaseVernalization, x2=Topt1Vernalization, x3=Topt2Vernalization, x4=TstopVernalization, y1=0, y2=1, y3=0))
}

fDegreeDays<-function(cTemp, Tbase) return(pmax(Tbase, cTemp))

fComputeCoefTemp<-function(cTemp, Tbase, Topt1, Topt2, Tstop) { 
 return(fFunctionstep(x=cTemp, x1=Tbase, x2=Topt1, x3=Topt2, x4=Tstop, y1=0, y2=1, y3=0))
}

fComputeSnowMelt<-function(iTASMax, iPr, sSnow) {
  return(ifelse(iTASMax<=1, 0, pmin(sSnow, iTASMax + iPr * 0.4))) # icicici: unit problem: we expect mm, but we have degrees... this equation has no meaning!
  #it comes from SNOMLT = TMAX + RAIN * 0.4
}

fComputeCorrectedPr<-function(iTASMax, iPr, cSnowMelt){
  return(ifelse(iTASMax<=1, 0, iPr + cSnowMelt )) #in cases where it s cold, it snows instead of raining so correctedPr=0, where it s hot, the snow melt is added to the rain
}

fComputeCrownTemperature<-function(sSnow,iTASMax,iTASMin){
  sSnow<-pmin(15, sSnow)
  TcrownMin<-iTASMin
  TcrownMax<-iTASMax
  TcrownMin[iTASMin < 0 & sSnow > 0]<- 2 + iTASMin * (0.4 + 0.0018 * (sSnow - 15) ^ 2)
  TcrownMax[iTASMax < 0 & sSnow > 0]<- 2 + iTASMax * (0.4 + 0.0018 * (sSnow - 15) ^ 2)
  return((TcrownMin + TcrownMax) / 2)
}

fPhotoperiodDuration<-function(iDate,latitude){
  doy=as.numeric(strftime(iDate, format = "%j"))
  RDN = pi / 180
  DEC = sin(23.45 * RDN) * cos(2 * pi * (doy + 10) / 365)
  DEC = atan(DEC / sqrt(1 - DEC ^ 2)) * -1
  DECL = DEC * 57.29578
  SINLD = sin(RDN * latitude) * sin(DEC)
  COSLD = cos(RDN * latitude) * cos(DEC)
  AOB = SINLD / COSLD
  AOB2 = atan(AOB / sqrt(1 - AOB ^ 2))
  DAYL = 12 * (1 + 2 * AOB2 / pi)
  return(DAYL + 0.9)
}

fComputeCoefPhotoperiodCrops<-function(pPhotoperiodFunction, photoDuration,CriticalPhotoPeriod,PhotoPeriodSensitivity){
  ppfun<-rep(1, length(pPhotoperiodFunction))
  for (funct in unique(pPhotoperiodFunction[!is.na(pPhotoperiodFunction)])) {
    whichcases<- (! is.na(pPhotoperiodFunction) & pPhotoperiodFunction==funct)
    if ("whichcases" %in% names(formals(funct))) {
      arguments<-list(photoDuration=photoDuration,
                      CriticalPhotoPeriod=CriticalPhotoPeriod,
                      PhotoPeriodSensitivity=PhotoPeriodSensitivity,
                      whichcases=whichcases)
    }else {
      arguments<-list(photoDuration=photoDuration[whichcases],
                      CriticalPhotoPeriod=CriticalPhotoPeriod[whichcases],
                      PhotoPeriodSensitivity=PhotoPeriodSensitivity[whichcases]
      )
    }
    ppfun[whichcases]<-do.call(funct, args=arguments)
  }
 return(ppfun)
}

fComputeCoefPhotoperiodWheat<-function(photoDuration,CriticalPhotoPeriod,PhotoPeriodSensitivity){
  ppfun <- ifelse(photoDuration < CriticalPhotoPeriod, 
                  pmax(0, 1 - PhotoPeriodSensitivity * (CriticalPhotoPeriod - photoDuration) ^ 2),
                  1)
  return(ppfun)
}

rComputeCoefPhotoperiodMaize<-function(photoDuration,CriticalPhotoPeriod,PhotoPeriodSensitivity, whichcases){
  #we cheat : this is supposed to be a function, i.e. use only arguments that are passed to it, 
  #but it is a procedure because it accesses parameters from ALLDAYDATA (cultivars) and from ALLCROPS (threshold EJU) 
  #instead of only the parameters that are passed to all the other photoperiod functions (pp, cpp, ppsen)
  cultivars<-paste(ALLDAYDATA$sCrop,ALLDAYDATA$sCultivar, sep=".")[whichcases]
  bdEJUTSI<-sapply(cultivars, function(cv) sapply(ALLCROPS[cv, "thresholds"], function(th) return(th["EJU"])))
  ppfun <- pmin(1, pmax(0, bdEJUTSI / (bdEJUTSI + PhotoPeriodSensitivity[whichcases] * (photoDuration[whichcases] - CriticalPhotoPeriod[whichcases]))))
  return(ppfun)
}

fComputeCoefPhotoperiodLegume<-function(photoDuration,CriticalPhotoPeriod,PhotoPeriodSensitivity){
  ppfun<-pmax(0, pmin(1, 1-PhotoPeriodSensitivity*(CriticalPhotoPeriod-photoDuration)))
  return(ppfun)
  # If ppsen >= 0 Then
  # ppfun = 1 - ppsen * (cpp - pp)
  # ElseIf ppsen < 0 Then
  # ppfun = 1 - (-ppsen) * (pp - cpp) #this is mathematically the same as the above
  # End If
  # If ppfun > 1 Then ppfun = 1
  # If ppfun < 0 Then ppfun = 0
  # 
}

fComputeCoefVernalization<-function(VernalizationSensitivity,VDSAT,sVernalization){
  CoefVernalization = pmax(0, pmin(1, 1 - VernalizationSensitivity * (VDSAT - sVernalization)))
  return(CoefVernalization)
}

fComputeDurationTSIMaize<-function(cTUbetweenEMRandTSI, pPhyllochron, pT1optDev, pTbaseDev){
  TLNO <- cTUbetweenEMRandTSI / (pPhyllochron * 0.5) + 5
  return((((TLNO + 0.5) * pPhyllochron) - cTUbetweenEMRandTSI) / (pT1optDev - pTbaseDev))
}

fComputeDecreaseLAIwithN<-function(DailyRateNfromLeave,SpecLeafNGreenLeaf,SpecLeafNSenescenceLeaf){
    return(DailyRateNfromLeave / (SpecLeafNGreenLeaf - SpecLeafNSenescenceLeaf))
}


fFrostEffect<-function(LAI,tasmin,FreezeThresholdTemp,FreezeFracLeafDestruction){
  DLAIF<-rep(0, length(LAI))
  frstf<-pmax(pmin((FreezeThresholdTemp-tasmin) * FreezeFracLeafDestruction,1),0)
  FreezeThresholdTemp[is.na(FreezeThresholdTemp)]<- -Inf
  DLAIF[tasmin<FreezeThresholdTemp] <- (frstf*LAI)[tasmin<FreezeThresholdTemp]
  return(DLAIF)
}

fHeatEffectSemenovSirius<-function(cDecreaseLAI,tasmax,HeatThresholdTemp,HeatFracLeafDestruction){
  DLAIH<-rep(0, length(cDecreaseLAI))
  heatf <- pmax(1 + (tasmax - HeatThresholdTemp) * HeatFracLeafDestruction, 1)              #Semenov-Sirius
  HeatThresholdTemp[is.na(HeatThresholdTemp)]<- Inf
  DLAIH[tasmax>HeatThresholdTemp] <- (heatf*cDecreaseLAI)[tasmax>HeatThresholdTemp]
  return(DLAIH)
}

#just in case we want to add a parameter in the crop file to select the type of LAI decrease response to heat
fHeatEffectAssengAPSIM<-function(cDecreaseLAI,tasmax,HeatThresholdTemp,HeatFracLeafDestruction){
  DLAIH<-rep(0, length(LAI))
  heatf = 4-(1 - (tasmax - 34) /2)              #Asseng-APSIM
  HeatThresholdTemp[is.na(HeatThresholdTemp)]<- Inf
  DLAIH[tasmax>HeatThresholdTemp] <- (heatf*cDecreaseLAI)[tasmax>HeatThresholdTemp]
  return(DLAIH)
}

#' Find the thickness of the rooted part of each layer
#' this is not really a function because it accesses global soil parameters
#' @param layers vector of target soil layer(s) (single value, or one layer per case)
#' @param df data.frame of state variables (ALLDAYDATA or ALLSIMULATEDDATA[[timestep]])
#'
#' @return if layers is finite, a vector (one element per layer), if layers is Inf, a matrix (cases in rows, layers in columns), of rooted thickness : when the roots go deeper, it is the depth of the layer, and in the last rooted layer, it is the length of roots inside this layer
#' @examples
#' #' \dontrun{
#' fFindRLYER(Inf, ALLDAYDATA)
#' fFindRLYER(c(1,1,2), ALLDAYDATA) #works only if there are 3 cases
#' }
#' 
fFindRLYER<-function(layers, df) {
  if (nrow(df) != nrow(ALLSOILS$paramlayers)) {
    whichcases <- rownames(ALLSOILS$paramlayers) %in% rownames(df) #if df contained only some of the cases, we need to tell fExtractSoilParameter which cases to take from the soil parameters array
  } else  whichcases<-TRUE
  rootFrontDepth<-df$sRootFrontDepth
  LayerThicknesses<-fExtractSoilParameter(paramname="pLayerThickness", layers=Inf, whichcases=whichcases)
  Layerceilings<-t(apply(LayerThicknesses, 1, cumsum))-LayerThicknesses
  rootedlength<-pmin(pmax(rootFrontDepth-Layerceilings,0), LayerThicknesses)
  if(any(!is.finite(layers))) { #all layers
    return(rootedlength)
  } else {
    return(rootedlength[cbind(1:nrow(df), layers)])
  }
}

#' Computes the WL (water content) or ATSW (available transpirable water) or TTSW (total transpirable soil water) or FTSW (fraction transpirable soil water) in a given layer (one for each case, or in all soil), weighted or not by the fraction of the layer that is colonized by roots
#' this is not really a function because it accesses global soil parameters
#' @param layers vector of target soil layer(s) (single value, or one layer per case) if Inf, returns all layers (as matrix: rows=cases, columns = layers) 
#' @param df data.frame of state variables (ALLDAYDATA or ALLSIMULATEDDATA[[timestep]])
#' @param what one of "ATSW", "TTSW", "FTSW", "WL"
#' @param weightedbyroots TRUE or FALSE, depending of wether the value should be weighted by the rooted proportion of the layer
#' @return if layers is Inf, a matrix (rows are cases, columns are layers), else a vector of ATSW in all cases of df, in the target layers
#' @examples
#'\dontrun{
#' fFindWater(layers=1, df=ALLDAYDATA, what="ATSW") #ATSW(1)
#' apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="ATSW", weightedbyroots=TRUE), 1, sum, na.rm=TRUE) #ATSWRZ
#' apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="FTSW", weightedbyroots=TRUE), 1, sum, na.rm=TRUE) #FTSWRZ
#' apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="WL", weightedbyroots=TRUE), 1, sum, na.rm=TRUE) # WRZ
#' apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="FTSW", weightedbyroots=FALSE),1,sum, na.rm=TRUE) #FTSWSL
#' apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="WL", weightedbyroots=FALSE),1,sum, na.rm=TRUE) #SWSL
#'}
fFindWater<-function(layers, df, what=c("ATSW", "TTSW", "FTSW", "WL", "WLUL", "WLST"), weightedbyroots=FALSE){
  what<-what[1]
  if (nrow(df) != nrow(ALLSOILS$paramlayers)) {
    whichcases <- rownames(ALLSOILS$paramlayers) %in% rownames(df) #if df contained only some of the cases, we need to tell fExtractSoilParameter which cases to take from the soil parameters array
  } else  whichcases<-TRUE
  #get water and make it into a matrix
  water<-as.matrix(df[,paste("sWater", 1:10, sep='.')])
  if (any(!is.finite(layers)))  WL<-water else WL<-as.matrix(water[cbind(1:nrow(water), layers)]) #water amount in the target layers
  #compute weigths (proportion of layer colonized by roots)
  if (weightedbyroots) {
    RLYER<-fFindRLYER(layers, df) #length of roots in each layer
    DLYER<-fExtractSoilParameter(paramname="pLayerThickness", layers=layers, whichcases= whichcases, keepcasesasrows = TRUE) #layer thickness
    weights<-RLYER/DLYER
  } else weights<-1 
  if (what=="WL") return(WL*weights)
  WLLL<-fExtractSoilParameter(paramname="pWiltingPoint", layers=layers, whichcases= whichcases, keepcasesasrows = TRUE)*fExtractSoilParameter(paramname="pLayerThickness", layers=layers, whichcases= whichcases, keepcasesasrows = TRUE) #amount of water at wilting point
  WLUL<-fExtractSoilParameter(paramname="pFieldCapacity", layers=layers, whichcases= whichcases, keepcasesasrows = TRUE)*fExtractSoilParameter(paramname="pLayerThickness", layers=layers, whichcases= whichcases, keepcasesasrows = TRUE) #amount of water at field capacity
  WLST<-fExtractSoilParameter(paramname="pSaturation", layers=layers, whichcases= whichcases, keepcasesasrows = TRUE)*fExtractSoilParameter(paramname="pLayerThickness", layers=layers, whichcases= whichcases, keepcasesasrows = TRUE) #amount of water at saturation
  if (what=="ATSW") {
    result<-(WL-WLLL)*weights
  } else if (what=="TTSW") {
    result<-(WLUL-WLLL)*weights
  } else if (what=="FTSW") {
    result<-((WL-WLLL)/(WLUL-WLLL))*weights
    ###### icicici issue #4 not yet solved "FTSWRZ=ATSWRZ/TTSWRZ instead of FTSWRZ=sum(FTSW*weights)" i don't remember what I meant....
  } else if (what=="WLUL") {
    result<-WLUL*weights
  } else if (what=="WLST") {
    result<-WLST*weights
  } else stop("what in fFindWater should be either ATSW, TTSW, FTSW, WL, WLUL or WLST")
  if (any(!is.finite(layers))) return(result) else return(drop(result))
}


#' Computes runoff
#'
#' @param vectorRain (corrected) rain
#' @param vectorCurveNumber Curve number  describing the soil infiltration capacity 
#' @param vectorSAT water content at full saturation in top layer
#' @param vectorLayerThickness thickness of top soil layer 
#' @param vectorWaterContent water content in soil layer 1
#' @param vectorWLL water content at wilting point in soil layer 1
#'
#' @return vector (one element per case) of runoff water
#' @examples
#' \dontrun{
#' fComputeRunoff(vectorrain=rain,
#' vectorCurveNumber=fExtractSoilParameter("pSoilCurveNumber"), 
#' vectorSAT=fExtractSoilParameter("pSaturation", layer=1),
#' vectorlayerthickness=fExtractSoilParameter("pLayerThickness", layer=1),
#' vectorwatercontent=ALLSIMULATEDDATA[[daybefore]][,"sWater.1"],
#' vectorWLL=fExtractSoilParameter("pWiltingPoint", layer=1)
#' }
fComputeRunoff<-function(vectorRain,
                         vectorCurveNumber, 
                         vectorSAT,
                         vectorLayerThickness,
                         vectorWaterContent,
                         vectorWLL){
  S <- 254 * (100 / vectorCurveNumber - 1)
  SWER <- pmax(0, 0.15 * ((vectorSAT*vectorLayerThickness - vectorWaterContent) / (vectorSAT*vectorLayerThickness - vectorWLL)))
  vectorrunof<-ifelse(vectorRain-SWER*S<0, 0, (vectorRain - SWER * S) ^ 2 / (vectorRain + (1 - SWER) * S))
  vectorrunof[vectorRain<=0.01]<-0
  return(vectorrunof)
}

#' Potential evapotranspiration following simplified Penman equation
#' icicici this function contains a lot of hard-coded parameters... they should be moved to sheet generalPhysicalParameters of allvariables
#' @param tmax daily max temperature
#' @param tmin daily min temperature
#' @param srad total daily solar radiation
#' @param calb crop albedo
#' @param ket canopy extinction coefficient
#' @param etlai LAI used for PET calculation (takes into account senesced leaves still attached to the plant and/or on the soil)
#' @param salb soil albedo
#' @return vector of PET (one element per case)
fComputePETsimplifiedPenman<-function(tmax, tmin, srad, calb, ket, etlai, salb) {
  td = 0.6 * tmax + 0.4 * tmin
  albedo = calb * (1 - exp(-ket * etlai)) + salb * exp(-ket * etlai)
  eeq = srad * (0.004876 - 0.004374 * albedo) * (td + 29)
  pet = eeq * 1.1
  pet[tmax > 34]<- eeq * ((tmax - 34) * 0.05 + 1.1)
  pet[tmax < 5]<- eeq * 0.01 * exp(0.18 * (tmax + 20))
  return(pet)
}

fComputeSoilEvaporationTwoStages<-function(vectorPet, vectorCanopyExtinctionCoefficient, vectorEtlai, atomicMinimalSoilEvaporation, 
                                           vectorStubbleWeight, vectorRain, vectorIrrigation, atomicpSoilWettingWaterQuantity) {
  
}


#' KN factor for mineralization computation
#' This factor models the response of the mineralization to soil temperature
#' The function allows its computation for a specific layer
#' That is, function inputs must be layer-specific values
#' @param soilTemp soil temperature
#' You would get soil temperature from either crown temperature : fComputeCrownTemperature(...)
#' or just assume it equal to daily mean temperature cTemp (if there's no snow)
#' @return computed KN based on soil temperature
fComputeKNforMineralization <- function(soilTemp){
  # soilTemp = cCrownTemperature (which computation function already exists)
  # icicici /!\ Hard-coded parameters in a quite obscure equation
  # Clarification of the equation would be welcome for code transparency
  return(24 * exp(17.753 - 6350.5/(soilTemp + 273)) / 168)
  # soilTemp likely converted from degrees to Kelvin with "+ 273" (Why though?)
}

#' RN factor for mineralization computation
#' This factor models the response of the mineralization process to soil moisture
#' The function allows its computation for a specific layer
#' That is, function inputs must be layer-specific values
#' @param fractionTranspirableSoilWater Fraction of transpirable soil water in the studied layer
#' Computed as the ratio of actual transpirable soil water (ATSW) to total(potential) transpirable soil water (TTSW)
#' You would get this parameter for the studied layer L with fFindWater(layer=L, df=ALLDAYDATA, what="FTSW")
#' @return computed RN based on soil moisture
fComputeRNforMineralization <- function(fractionTranspirableSoilWater) {
  # get fractionTranspirableSoilWater of current layer L with
  # fFindWater(layer=L, df=ALLDAYDATA, what="FTSW")
  if (fractionTranspirableSoilWater < 0.9) {
    RN <- 1.111 * fractionTranspirableSoilWater
    # Can't be negative unless there's a bug in FTSW computation
  } else {
    RN <- max(0, 10 - 10*fractionTranspirableSoilWater)
  }
  return (RN)
}


#' Computation of N mineralization in specific layer
#' This function computes the net mineralization amount the present day for a specific layer
#' That is, function inputs must be layer-specific values
#' @param mineralizableN Amount of organic N readily mineralizable (MNORG) in studied layer
#' @param solubleNconcentration Concentration of soluble N in the layer's soil solution (NCON)
#' @param RN Factor of soil temperature on mineralization
#' @param KN Factor of soil moisture on mineralization
#' @return Net mineralization amount for the given layer inputs
fComputeNMineralization <- function(mineralizableN, solubleNconcentration, RN, KN) {
  return(max(0, mineralizableN * RN * (1 - exp(-KN)) * (0.0002 - solubleNconcentration) / 0.0002))
}


#' Computation of daily N drainage out of a specific layer
#' Computes the amount of soluble N that drains out a specific layer into the layer below because of water downward flux
#' That is, function inputs must be layer-specific values
#' If that layer is the last of the system, then it represents the N leaching out the system (into the environment)
#' The model considers that at very-low concentration, N drainage is non-existent
#' The threshold accounting for this limitation is the minCon argument, defaulted to 0.000001 mg.L-1
#' @param solubleNAmount the amount of soluble N present in the layer's soil solution (NSOL)
#' @param waterDrainage the amount of water drained out the layer into the layer below (FLOUT)
#' @param waterContent the amount of water present in the current layer (WL)
#' @param minCon minimum concentration threshold below which N drainage is likely non-existent (defaulted to 0.000001 mg.L-1)
#' @param solubleNConcentration the concentration of soluble N in the current layer soil solution (NCON)
#' @return Amount of N drained out and below the layer which corresponding inputs were given (NOUT, g.m-2)
fComputeNDrainage <- function(solubleNAmount, waterDrainage, waterContent, solubleNConcentration, minCon = 0.000001) {
  if (solubleNConcentration <= minCon) {
    NOUT = 0
  } else {
    NOUT = solubleNAmount * (waterDrainage / (waterContent+waterDrainage) )
  }
  return (NOUT)
}

#' XNCON computation for denitrification
#' When computing denitrification, soluble N concentration in the layer is not directly used
#' Instead, it is limited to a maximum threshold since further increase has limited to no effect
#' This threshold is set to 0.0004 mg.L-1 by default (as in the model documentation)
#' This function returns the NCON for a specific layer which specific NCON has been given for input
#' @param solubleNConcentration soluble N concentration of the layer (NCON)
#' @param threshold concentration threshold over which further increase has little to no effect on process (default = 0.0004 mg.L-1)
#' @return max(solubleNConcentration, threshold) (XNCON, mg.L-1)
fComputeXNCONforDenit <- function(solubleNConcentration, threshold=0.0004) {
  return(max(solubleNConcentration, threshold))
}


#' KDNIT factor computation for denitrification
#' Computes the KDNIT factor modeling the effect of soil temperature on the denitrification process
#' @param soilTemp the soil temperature
#' You would get this from fComputeCrownTemperature or just set it equal to the air temperature if there's no snow to account for
#' @return computed KDNIT factor for computation of N denitrification
fComputeKDNIT <- function (soilTemp) {
  # icicici /!\ Hard-coded parameters results in an obscure code line
  # Clarification would be welcome
  return (6 * exp(0.07735 * TMPS - 6.593))
}

#' N denitrification in a given layer
#' @param fractionTranspirableWater fraction of transpirable soil water in the layer (FTSW)
#' @param KDNIT the KDNIT rate factor (fComputeKDNIT) modeling the effect of soil temperature on denitrification
#' @param effectiveNConcentration soluble N concentration in the layer, limited to a maximum threshold (default=0.0004 mg.L-1)
#' @param waterContent the amount of water in the giver layer (mm)
#' @param waterFactor icicicicici /!\ Supposdely /!\ the fraction of the day where there's enough water for denitrification (FTSW > 1)
#' @return computed amount of N denitrification in the layer (g.m-2)
fComputeNDenitrification <- function (fractionTranspirableWater, KDNIT, effectiveNConcentration, waterContent, waterFactor = 1) {
  return (ifelse(fractionTranspirableWater>1, # if FTSW > 1
                 effectiveNConcentration * (1 - exp(-KDNIT)) * waterContent * 1000 * waterFactor,
                 #                                               * 1000 used for unit conversion
                 0)) # else, no N denitrification
}

#' N removal by uptake computation
#' Computes the amount of N absorbed out a given soil layer by the plant roots (uptake)
#' @param layerAvailableSoilN studied layer's N ressources that crop has access to (NAVL, g.m-2)
#' @param totalAvailableSoilN whole soil N ressources that crop has access to (SNAVL, g.m-2)
#' @param plantNUptake the crop's demand in N uptake (NUP, g.m-2)
#' @param plantNFixation the crop's air nitrogen fixation (BNF, g.m-2, 0 for non-legume crops)
#' @return Amount of N loss by plant uptake in the given layer (NU, g.m-2)
fComputeNRemovalByUptake <- function (layerAvailableSoilN, totalAvailableSoilN, plantNUptake, plantNFixation) {
  return ( (layerAvailableSoilN / (totalAvailableSoilN + 0.000001)) * (plantNUptake - plantNFixation) )
}

#' Computation of soluble N amount in a specific layer (NSOL)
#' @param soilMass soil mass (SOILML, g m-2) computed from bulk density BDL, coarse fraction FG and layer thickness DLYER
#' @param ppmNO3L ppm concentration of NO3 nitrate in the layer
#' @param ppmNH4L ppm concentration of NH4 nitrate in the layer
#' @return the amount of soluble N (NO3+NH4) in the given layer (g (of N) .m-2)
fComputeSolubleN <- function (soilMass, ppmNO3L, ppmNH4L) {
  NO3L <- ppmNO3L * (14/62) * 0.000001 * soilMass
  NH4L <- ppmNH4L * (14/18) * 0.000001 * soilMass
  return (NO3L + NH4L)
}

#' Computation of soil mass of a specific layer (SOILML, g.m-2)
#' @param layerThickness the depth/thickness of the given layer (DLYER, mm)
#' @param bulkDensity the layer's bulk density (BDL, g.cm-3)
#' @param coarseFraction the fraction of gross particles (>2mm) in the soil (FG)
#' @return the soil mass of a specific layer (SOILML, g.m-2)
fComputeSoilMass <- function (layerThickness, bulkDensity, coarseFraction) {
  return (layerThickness * bulkDensity * (1-coarseFraction) * 1000)
}

#' Computation of mineralizable N amount in a specific layer
#' @param soilMass soil mass of the layer (SOILML, g m-2)
#' @param organicNPercentage percentage of organic N in the soil total mass
#' @param FMIN estimate fraction of organic N that's mineralizable
#' @return amount of N that's readily available for mineralization
fComputeMineralizableN <- function (soilMass, organicNPercentage, FMIN) {
  return (organicNPercentage * 0.01 * soilMass * FMIN)
}

#' function (but with access to global variables) to compute the variables needed to determine sowing
#'
#' @param whichcases logical vector indicating which cases to use for computing
#' @param what one of "cumuRain5days", "temp", "FTSW1", "ATSWwholeSoil"
#' @return the variable that was requested, for the requested cases
#' @examples
#' fVariablesForSowing()
fVariablesForSowing<-function(whichcases=TRUE, what=c("cumuRain5days", "temp", "FTSW1", "ATSWwholeSoil")) {
  what<-what[1]
  if (what=="cumuRain5days") {
    timestep<-length(ALLSIMULATEDDATA)
    if(timestep<5) return(NA) else
      return(rowSums(do.call(cbind, lapply(ALLSIMULATEDDATA[(timestep-5): timestep], "[", whichcases, "iPr", drop=FALSE))))
  } else if (what=="temp") {
    return((ALLDAYDATA[whichcases, "iTASMax"]+ALLDAYDATA[whichcases, "iTASMin"])/2)
  } else if (what=="FTSW1") {
    return(fFindWater(layers=1, df=ALLDAYDATA[whichcases,, drop=FALSE], what="FTSW"))
  } else if (what=="ATSWwholeSoil") {
    return(apply(fFindWater(layers=Inf, df=ALLDAYDATA[whichcases,, drop=FALSE], what="ATSW"),1,sum, na.rm=TRUE))
  } else stop("function fVariablesForSowing cannot compute", what)
}


################################ procedures

#####Weather module
rWeatherDay<-function(){
  #print("Updating weather intput")
  Dateoftheday<-ALLDAYDATA[1,"iDate"]
  dfclimate<-fGetClimateDay(date=Dateoftheday)
  climatevariables<-VARIABLEDEFINITIONS[VARIABLEDEFINITIONS$module=="rWeatherDay" & VARIABLEDEFINITIONS$typeinthemodel=="input","name"]
  ALLDAYDATA[,climatevariables]<<-dfclimate[PARAMSIM$cases$climatename, climatevariables]
  cSnowMelt<-fComputeSnowMelt(sSnow=ALLDAYDATA$sSnow,iTASMax=ALLDAYDATA$iTASMax,iPr=ALLDAYDATA$iPr)
  cPrCorrected<-fComputeCorrectedPr(cSnowMelt=cSnowMelt,iTASMax=ALLDAYDATA$iTASMax,iPr=ALLDAYDATA$iPr)
  sSnow<-ALLDAYDATA$sSnow + ALLDAYDATA$iPr -  cPrCorrected #if temp<=1, prcorrected = 0 and all rain is snow ; if temp>1, cPrCorrected = iPr-snowmelt so snowmelt=ipr - cPr
  #warning: this equation for sSnow is true only if the temperature threshold for snowmelt is the same as the temperature threshold for snowing
  ALLDAYDATA[,c("cSnowMelt","cPrCorrected","sSnow")]<<-data.frame(cSnowMelt,cPrCorrected,sSnow)
}


#### Management module 
rFindWhoSows<-function(){
  doy<-as.POSIXlt(ALLDAYDATA$iDate[1])$yday+1
  cCycleEndType<-ALLDAYDATA$cCycleEndType
  sLastSowing<-ALLDAYDATA$sLastSowing
  #find the sowing window for each case
  sowingwindowstart<-rep(Inf, nrow(ALLDAYDATA))
  sowingwindowend<-rep(-Inf, nrow(ALLDAYDATA))
  for (manag in unique(ALLDAYDATA$sManagement)) {
    sowingwindowstart[ALLDAYDATA$sManagement==manag]<-ALLMANAGEMENTS[[manag]]$dfSowing$Fpdoy
    sowingwindowend[ALLDAYDATA$sManagement==manag]<-ALLMANAGEMENTS[[manag]]$dfSowing$Lpdoy
  }
  withinsowingwindow<-( ((sowingwindowstart<=sowingwindowend & doy>=sowingwindowstart & doy<=sowingwindowend) #summer crop
                        |  (sowingwindowstart>sowingwindowend & (doy>=sowingwindowstart | doy<sowingwindowend)) ) #winter crop
  ) & ALLDAYDATA$sLastSowing<ALLDAYDATA$sLastHarvest #to avoid sowing again something that is already sowed
  #find the sowing type the thresholds (sowwat and sowtemp) for each case (type depends on crop)
  sowingtype<-factor(rep(8, nrow(ALLDAYDATA)), levels=c(
    "5 days without rain", 
    "5 days without rain  and temp>SowTmp",
    "5 days without rain  and temp<SowTmp",
    "FTSW1>SowWat",
    "FTSW1<SowWat",
    "cumulated rainfall over 5 days > SowWat",
    "ATSW whole soil > SowWat",
    "fixed doy" #last because levels are numbered from 1 to n, but this was code 0
    ))
  waterthreshold<-numeric(nrow(ALLDAYDATA))
  tempthreshold<-numeric(nrow(ALLDAYDATA))
  for (manag in unique(ALLDAYDATA$sManagement[withinsowingwindow])) {
    sowingtype[ALLDAYDATA$sManagement==manag]<-levels(sowingtype)[ALLMANAGEMENTS[[manag]]$dfSowing$FixFind]
    waterthreshold[ALLDAYDATA$sManagement==manag]<-ALLMANAGEMENTS[[manag]]$dfSowing$SowWat
    tempthreshold[ALLDAYDATA$sManagement==manag]<-ALLMANAGEMENTS[[manag]]$dfSowing$SowTmp
  }
  #compute the necessary variables for each type and compare with the thresholds for each case
  sowingday<-rep(FALSE, nrow(ALLDAYDATA))
  for(type in unique(sowingtype[withinsowingwindow])) {
    tobetested<- withinsowingwindow & sowingtype==type
    if(type == "5 days without rain") {
      test<-fVariablesForSowing(whichcases=tobetested, what="cumuRain5days")==0
    } else if(type == "5 days without rain  and temp>sowtemp") {
      test<-(
        fVariablesForSowing(whichcases=tobetested, what="cumuRain5days")==0
        & fVariablesForSowing(whichcases=tobetested, what="temp") > tempthreshold[tobetested]
      )
    } else if(type == "5 days without rain  and temp<sowtemp") {
      test<-(
        fVariablesForSowing(whichcases=tobetested, what="cumuRain5days")==0
        & fVariablesForSowing(whichcases=tobetested, what="temp") < tempthreshold[tobetested]
      )
    } else if(type == "FTSW1>SowWat") {
      test<-(
        fVariablesForSowing(whichcases=tobetested, what="FTSW1")>= waterthreshold[tobetested]
      )
    } else if(type == "FTSW1<SowWat") {
      test<-(
        fVariablesForSowing(whichcases=tobetested, what="FTSW1")<= waterthreshold[tobetested]
      )
    } else if(type == "cumulated rainfall over 5 days > SowWat") {
      test<-(
        fVariablesForSowing(whichcases=tobetested, what="cumuRain5days") > waterthreshold[tobetested]
      )
    }  else if(type == "ATSW whole soil > SowWat") {
      test<-(
        fVariablesForSowing(whichcases=tobetested, what="ATSWwholeSoil") > waterthreshold[tobetested]
      )
    }  else test<-TRUE #fixed sowing=>as soon as within the sowing window, we sow
    sowingday[tobetested]<- test
  }
  #update sLastSowing
  sLastSowing[sowingday]<-length(ALLSIMULATEDDATA) #ALLDAYDATA$iDate[1] 
  ##if the sowing window end is reached and nothing is sowed, go to next crop in the rotation, i.e. do the "harvest" operation
  cCycleEndType[sowingwindowend==doy & sLastSowing<ALLDAYDATA$sLastHarvest]<-"not sowed"
    
  ALLDAYDATA[, c("sLastSowing", "cCycleEndType")]<<-data.frame(sLastSowing, cCycleEndType)
}
rSowing<-function(){
  whosows<-ALLDAYDATA$sLastSowing==length(ALLSIMULATEDDATA) #ALLDAYDATA$iDate[1]
  if(any(whosows)) {
    df<-ALLDAYDATA[whosows,]
    splits<-strsplit(df$sCropCult, split=".", fixed=TRUE)
    df$sCrop<-sapply(splits,"[[", 1)
    df$sCultivar<-sapply(splits,"[[", 2)
    #update crop parameters according to crop and cultivar (do it now even if usually it is done just after sowing, because... I don't remember why)
    cropparameters<-VARIABLEDEFINITIONS[VARIABLEDEFINITIONS$typeinthemodel =="CropParameter", "name"]
    cultivars<-paste(df$sCrop, df$sCultivar, sep=".")
    possiblecrops<-unique(cultivars)
    missing<-setdiff(cropparameters, names(ALLCROPS))
    if(length(missing)>0) warning("the following parameters are mising from crop parameters: ", paste(missing, collapse=", "))
    paramstobechanged<-intersect(cropparameters, names(ALLCROPS))
    df[, paramstobechanged]<-ALLCROPS[cultivars, paramstobechanged]
    #initialize management
    #df$cCycleEndType<-"not yet" #icicici check why this is commented out 
    #initialize phenology
    df$sGrowthStageNumber<-1
    df$sGrowthStage<-mapply(function(thresh, num) return(names(thresh)[num]),
                            ALLCROPS[df$sCropCult, "thresholds"], 
                            df$sGrowthStageNumber
    )
    df$sDurationStage<-mapply(function(cropname, stage) return(ALLCROPS[cropname,"thresholds"][[1]][stage]),
                              df$sCropCult, 
                              as.character(df$sGrowthStage), SIMPLIFY = TRUE, USE.NAMES=FALSE
    )
    df$sBiologicalDay<-0
    #initialize other things
    df$sPlantdensity<-sapply(ALLMANAGEMENTS[df$sManagement], function(x) x$dfSowing$Pden)
    #stubleWeight is initialized by harvest, at the same time as management change, because it is necessary for soil evaporation before sowing
    df$sRootFrontDepth<-as.numeric(ALLCROPS[df$sCropCult,"iDEPORT"])
    #initialize all other crop-related variables to their default value
    variablestoinitialize<-setdiff(
      VARIABLEDEFINITIONS[VARIABLEDEFINITIONS$typeinthemodel == "stateVariable"
                          & VARIABLEDEFINITIONS$module %in% c(
                            "rUpdateStresses", "rUpdatePhenology", "rUpdateLAI",
                            "rUpdateDMProduction", "rUpdateDMDistribution", "rUpdateRootDepth"
                          ), "name"],
      c("sCrop", "sCultivar", "sGrowthStageNumber", "sGrowthStage", "sDurationStage", 
        "sBiologicalDay", "sPlantdensity", "sStubleWeight", "sRootFrontDepth")
    )
    numericvariables<-variablestoinitialize[VARIABLEDEFINITIONS[variablestoinitialize,"typeR"]=="numeric"]
    df[,variablestoinitialize]<-VARIABLEDEFINITIONS[variablestoinitialize, "defaultInitialvalue"]
    df[,numericvariables]<-lapply(df[,numericvariables],as.numeric)
    #update ALLDAYDATA
    ALLDAYDATA[whosows,names(df)]<<-df
  }
}

rFindWhoHarvests<-function(){
  sLastHarvest<-ALLDAYDATA$sLastHarvest
  cCycleEndType<-factor(NA, levels=c("normal", "low LAI", "not sowed", "stopDAP", "killed by flood", "not yet"))
  cCycleEndType[sLastHarvest<ALLDAYDATA$sLastSowing]<-"not yet"
  harvestday<-rep(FALSE, nrow(ALLDAYDATA))
  #last stage reached
  cultivars<-paste(ALLDAYDATA$sCrop, ALLDAYDATA$sCultivar, sep=".")
  numlaststages<-sapply(ALLCROPS[cultivars,"thresholds"], length)#{toto<- x$thresholds ; return(names(toto)[length(toto)])})
  reachedMaturity<-sLastHarvest<ALLDAYDATA$sLastSowing & ALLDAYDATA$sGrowthStageNumber==numlaststages
  reachedMaturity[is.na(reachedMaturity)]<-FALSE
  #lowLAI
  duringSeedGrowth<-applyfilters("DMDistribution_SeedGrowing")
  LowLAI<-duringSeedGrowth & ALLDAYDATA$sLAI<GENERALPARAMETERS["pTresholdLowLAIdeath", "defaultInitialvalue"]
  LowLAI[is.na(LowLAI)<-FALSE]
  #stopDAP parameter reached
  doy<-as.POSIXlt(ALLDAYDATA$iDate[1])$yday+1
  stopDAP<-sapply(ALLMANAGEMENTS[ALLDAYDATA$sManagement], function(x) x$dfSowing$StopDAP)
  reachedStopDAP<-sLastHarvest<ALLDAYDATA$sLastSowing & doy==stopDAP
  reachedStopDAP[is.na(reachedStopDAP)]<-FALSE
  # flooding (or anoxia?)
  flooding<-sLastHarvest<ALLDAYDATA$sLastSowing & ALLDAYDATA$sFloodDuration>ALLDAYDATA$pFloodLengthDeath
  # icicici warning: the initial code says CBD = bdTSG: MATYP = 5, does it mean that seed growth stops, but the maturation continues normally?
  #in this case, we should not put this code in rHarvest, but in rUpdatePhenology because it is just accelerating phenology, not killing the plant.
  #For now I leave it here because the explaination of MATYP says "Flood kill"
  flooding[is.na(flooding)]<-FALSE
  
  cCycleEndType[reachedMaturity]<-"normal"
  cCycleEndType[LowLAI]<-"low LAI"
  #cCycleEndType[FALSE]<-"not sowed" #done in the rFindWhoSows procedure
  cCycleEndType[reachedStopDAP]<-"stopDAP"
  cCycleEndType[flooding]<-"killed by flood"
  harvestday[!is.na(cCycleEndType) & cCycleEndType!="not yet"]<-TRUE
  #update sLastHarvest
  sLastHarvest[harvestday]<-length(ALLSIMULATEDDATA)#ALLDAYDATA$iDate[1] 
  
  ALLDAYDATA[,c("cCycleEndType", "sLastHarvest")]<<-data.frame(cCycleEndType, sLastHarvest)
}
rHarvesting<-function(){
  whoharvests<-ALLDAYDATA$sLastHarvest==length(ALLSIMULATEDDATA) #ALLDAYDATA$iDate[1]
   if(any(whoharvests)) {
    df<-ALLDAYDATA[whoharvests,]
    #find the next crop in the rotation
    rotations<-PARAMSIM$cases$rotation[whoharvests]
    nextnum<-ALLDAYDATA$sCropNum[whoharvests]+1
    nextnum[nextnum>sapply(rotations, length)]<-1 #last crop finished=>we start again the rotation
    #reset all crop parameters and state variables to their default values
    cropparam<-VARIABLEDEFINITIONS[VARIABLEDEFINITIONS$typeinthemodel =="CropParameter", "name"]
    numericparam<-cropparam[VARIABLEDEFINITIONS[cropparam,"typeR"]=="numeric"]
    df[,cropparam]<-VARIABLEDEFINITIONS[cropparam, "defaultInitialvalue"]
    df[,numericparam]<-lapply(df[,numericparam],as.numeric)
    variablestoinitialize<-VARIABLEDEFINITIONS[VARIABLEDEFINITIONS$typeinthemodel == "stateVariable"
                          & VARIABLEDEFINITIONS$module %in% c(
                            "rUpdateManagement",  "rUpdateStresses", "rUpdatePhenology", "rUpdateLAI",
                            "rUpdateDMProduction", "rUpdateDMDistribution", "rUpdateRootDepth", "PlantN" #icicici when it's coded, rename this module with a procedure name
                          ), "name"]
    #check which one we kep:
    #setdiff(VARIABLEDEFINITIONS[VARIABLEDEFINITIONS$typeinthemodel == "stateVariable","name"], variablestoinitialize)
    #should be "sDaysSinceStage2evaporation", "sWater.1" to "sWater.10", "sSnow"                      
    variablestoinitialize<-setdiff(variablestoinitialize, c("sLastHarvest", "sLastSowing", "cCycleEndType"))
    numericvariables<-variablestoinitialize[VARIABLEDEFINITIONS[variablestoinitialize,"typeR"]=="numeric"]
    defaults<-VARIABLEDEFINITIONS[variablestoinitialize, "defaultInitialvalue"] ; names(defaults)<-variablestoinitialize
    df[,variablestoinitialize]<-lapply(defaults, rep, times=nrow(df))
    df[,numericvariables]<-lapply(df[,numericvariables],as.numeric)
    #df$sCrop<-NA #done by rSowing
    #df$sCultivar<-NA #done by rSowing
    #prepare for sowing: indicate the next crop and management
    df$sCropNum<-nextnum
    df$sCropCult<-mapply("[", rotations, nextnum)
    df$sManagement<-mapply("[", PARAMSIM$cases$management[whoharvests], nextnum)
    #initialize sStubleWeight (necessary for soil evaporation during the fallow period)
    df$sStubleWeight<-sapply(ALLMANAGEMENTS[df$sManagement], function(x) x$dfSowing$STBLW) #because it is necessary before sowing so it cannot be initialized at sowing like the other variables
    ALLDAYDATA[whoharvests,names(df)]<<-df
  }
}


rIrrigation<-function() {
  cIrrigationWater<-rep(VARIABLEDEFINITIONS["cIrrigationWater", "defaultInitialvalue"], nrow(ALLDAYDATA))
  sIrrigationNumber<-ALLDAYDATA$sIrrigationNumber
  waterscenarios<-sapply(ALLMANAGEMENTS[ALLDAYDATA$sManagement], "[[", "waterScenario") 
  #codes of water management: 0 = potential production (soil water not necessary to compute), 1 = automated irrigation to keep soil water above a certain threshold, 2: rainfed (no irrigation), 3 fixed according to data frame
  
  #### 0 (potential production: do nothing
  #### 1 automatic irrigation of 30 mm if TSWRZ <= IRGLVL And CBD < bdTSG 
  irrigationThresholds<-sapply(ALLMANAGEMENTS[ALLDAYDATA$sManagement], "[[", "waterLevel") 
  FTSWweightedByRoots<-apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="FTSW", weightedbyroots=TRUE), 1, sum, na.rm=TRUE) #FTSWRZ with water content from yesterday and root length from yesterday
  ###icicicici FTSWRZ is computed three times, once here and once in waterbudget and once in rUpdateStresses, because we decided not to save layer-related soil variables, except water content
  ##we won't save it here icicici check that is it saved only by one procedure, and write the name of this procedure in allvariables.xlsx
  resultfilter<-applyfilters("automaticIrrigation")
  irrigation1<-waterscenarios==1 & FTSWweightedByRoots<=irrigationThresholds & resultfilter
  cIrrigationWater[irrigation1]<-30
  sIrrigationNumber[irrigation1]<-sIrrigationNumber[irrigation1]+1
  
  #### 2 rainfed: do nothing
  
  #### 3 fixed irrigation
  irrigationnumberchecked<-ALLDAYDATA$sIrrigationNumber+1 #check if today is the day of the next irrigation (from alldaydata=>from yesterdays irrigation number)
  thresholds<-mapply(function(df,rownum) return(df[rownum,"DAPorCBDorDOY"]), df=lapply(ALLMANAGEMENTS[ALLDAYDATA$sManagement], "[[", "waterdf"), rownum=irrigationnumberchecked)
  amounts<-mapply(function(df,rownum) return(df[rownum,"amount"]), df=lapply(ALLMANAGEMENTS[ALLDAYDATA$sManagement], "[[", "waterdf"), rownum=irrigationnumberchecked)
  waterdatetypes<-sapply(ALLMANAGEMENTS[ALLDAYDATA$sManagement], "[[", "waterDatetype") 
  DAP<-length(ALLSIMULATEDDATA)-ALLDAYDATA$sLastSowing
  CBD<-ALLDAYDATA$sBiologicalDaysSinceSowing
  DOY<-as.POSIXlt(ALLDAYDATA$iDate[1])$yday+1
  
  irrigation3.1<-waterscenarios==3 & waterdatetypes==1 & DAP==thresholds # 1 DAP
  cIrrigationWater[irrigation3.1]<-amounts[irrigation3.1]
  sIrrigationNumber[irrigation3.1]<-sIrrigationNumber[irrigation3.1]+1
  
  irrigation3.2<-waterscenarios==3 & waterdatetypes==2 & CBD>=thresholds # 2 CBD
  cIrrigationWater[irrigation3.2]<-amounts[irrigation3.2]
  sIrrigationNumber[irrigation3.2]<-sIrrigationNumber[irrigation3.2]+1
  
  irrigation3.3<-waterscenarios==3 & waterdatetypes==3 & thresholds==DOY # 3 DOY
  cIrrigationWater[irrigation3.3]<-amounts[irrigation3.3]
  sIrrigationNumber[irrigation3.3]<-sIrrigationNumber[irrigation3.3]+1
  
  irrigation3.4<-waterscenarios==3 & waterdatetypes==4 & CBD>=thresholds # 3 CBD with automatic amount to fill to field capacity
  amounts<-(apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="TTSW", weightedbyroots=TRUE), 1, sum, na.rm=TRUE)
            -apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="ATSW", weightedbyroots=TRUE), 1, sum, na.rm=TRUE))#TTSWRZ-ATSWRZ with water content from yesterday and root length from yesterday
  cIrrigationWater[irrigation3.4]<-amounts[irrigation3.4]
  sIrrigationNumber[irrigation3.4]<-sIrrigationNumber[irrigation3.4]+1
  
  #update computed and state variable
  ALLDAYDATA[,c("cIrrigationWater", "sIrrigationNumber")]<<-data.frame(cIrrigationWater, sIrrigationNumber)
  return()
}

rUpdateManagement<-function(){
  #print("Updating crops according to crop management")
  #DOY<-as.POSIXlt(ALLDAYDATA[1,"iDate"])$yday+1
  #whosows
  rFindWhoSows() #writes the current date into ALLDAYDATA$sLastSowing
  rSowing() #initialize crop variables
  rSetParamsFromCrops() #assign the crop parameters according to the crop present (i.e. do it again fro crops that are just sowed today, but we need it for the other cases as well)
  rFindWhoHarvests() #writes the current date into ALLDAYDATA$sLastHarvest
  rHarvesting()
  #whofertilizes
  rIrrigation()
}

#### computation of water stresses and N stresses, from water level and nitrogen of the previous day
#do it now because they are used by several modules
rUpdateStresses<-function(){
  sFloodDuration<-ALLDAYDATA$sFloodDuration
  cFTSWrootZone<-apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="FTSW", weightedbyroots=TRUE), 1, sum, na.rm=TRUE) #FTSWRZ
  ###icicicici this is computed three times, once here and once in waterbudget, because we decided not to save layer-related soil variables, except water content, and once in rIrrigation to compute FTSWRZ for irrigating or not
  #### and we need it now just to compute AROOT, because in the code, AROOT from last time step is used to compute WUUR before updating aroot, don't know why
  rootLength_L<-fFindRLYER(Inf, ALLDAYDATA) #RLYER
  FTSW_L<-fFindWater(layers=Inf, df=ALLDAYDATA, what="FTSW", weightedbyroots=FALSE) #FTSW(l)
  waterStressTranspiration_L<-pmax(pmin(FTSW_L/ALLDAYDATA$pThresholdWaterStressGrowth, 1),0 ) #RT(L)
  cAvailableWaterInRootZone<-apply(rootLength_L*waterStressTranspiration_L, 1, sum, na.rm=TRUE) #AROOT
  
  cCoefWaterstressGrowth<-pmin(1, cFTSWrootZone/ALLDAYDATA$pThresholdWaterStressGrowth) #WSFG 
  cCoefWaterstressLeafArea<-pmin(1, cFTSWrootZone/ALLDAYDATA$pThresholdWaterStressLeafArea) #WSFL
  cCoefWaterstressDevelopment<-(1-cCoefWaterstressGrowth)*ALLDAYDATA$pCoefWaterStressGrowthToDevelopment+1 #WSFD 

  waterWeightedByRoots<-apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="WL", weightedbyroots=TRUE), 1, sum, na.rm=TRUE) #WRZ
  waterFieldCapacityWeightedByRoots<-apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="WLUL", weightedbyroots=TRUE), 1, sum, na.rm=TRUE) #WRZUL
  waterSaturationWeightedByRoots<-apply(fFindWater(layers=Inf, df=ALLDAYDATA, what="WLST", weightedbyroots=TRUE), 1, sum, na.rm=TRUE) #WRZST
  cCoefWaterStressSaturation<-pmin(pmax(((waterSaturationWeightedByRoots - waterWeightedByRoots) / (waterSaturationWeightedByRoots - waterFieldCapacityWeightedByRoots)), 0), 1) #WSXF
  cCoefWaterstressGrowth[cFTSWrootZone>1]<-cCoefWaterStressSaturation[cFTSWrootZone>1]
  cCoefWaterstressLeafArea[cFTSWrootZone>1]<-cCoefWaterStressSaturation[cFTSWrootZone>1]
  saturated<-cCoefWaterStressSaturation<=GENERALPARAMETERS["pWaterStressSaturationFlood", "defaultInitialvalue"]
  saturated[is.na(saturated)]<-FALSE
  sFloodDuration[saturated]<-(sFloodDuration+1)[saturated]
  sFloodDuration[!saturated]<-0
    
  ALLDAYDATA[,c("cAvailableWaterInRootZone", "cFTSWrootZone", "cCoefWaterstressGrowth", 
                "cCoefWaterstressLeafArea", "cCoefWaterstressDevelopment",
                "cCoefWaterStressSaturation", "sFloodDuration")]<<-data.frame(
                  cAvailableWaterInRootZone, cFTSWrootZone, cCoefWaterstressGrowth, 
                  cCoefWaterstressLeafArea, cCoefWaterstressDevelopment,
                  cCoefWaterStressSaturation, sFloodDuration
                )
  
}

#####phenology module

#special procedure that is run only at stage change from EJU to SIL for Maize, to compute the duration of TSI stage
#this procedure has arguments (the cases where it has to be run) and returns the values, but it can access ALLDAYDATA and ALLSIMULATEDDATA
rComputeTSISILdurationMaize<-function(whichcases){
  #find deltaTU between EMR (i.e. the TU at the last occurence of SOW from ALLSIMULATEDDATA) and now (from ALLDAYDATA)
  TUmatrix<-as.data.frame(lapply(ALLSIMULATEDDATA, function(x) return(x[whichcases,"sThermalUnit"])))
  GSmatrix<-as.data.frame(lapply(ALLSIMULATEDDATA, function(x) return(x[whichcases,"sGrowthStage"])))
  daylastSOW<-apply(GSmatrix, 1, function(x) max(which(x=="SOW")))
  #get the TU by extracting, for each line, the column corresponding to the day of the last SOW stage
  TUlastSOW<-TUmatrix[cbind(
    seq_len(nrow(TUmatrix)),
    daylastSOW
  )]
  TuEMRTIL<-ALLDAYDATA$sThermalUnit[whichcases]-TUlastSOW
  pPhyllochron<-ALLDAYDATA$pPhyllochron[whichcases]
  pTopt1dev<-ALLDAYDATA$pTopt1dev[whichcases]
  pTbasedev<-ALLDAYDATA$pTbasedev[whichcases]
  duration<-((TuEMRTIL/(0.5*pPhyllochron)+5)*pPhyllochron-TuEMRTIL)/(pTopt1dev-pTbasedev)
  ALLDAYDATA$sDurationStage[whichcases]<<-duration
}

rUpdatePhenology<-function(){
  #print("Updating phenology")
  cultivars<-paste(ALLDAYDATA$sCrop, ALLDAYDATA$sCultivar, sep=".")
  sThermalUnit<-ALLDAYDATA$sThermalUnit
  sBiologicalDay<-ALLDAYDATA$sBiologicalDay
  sBiologicalDaysSinceSowing<-ALLDAYDATA$sBiologicalDaysSinceSowing
  sGrowthStage<-ALLDAYDATA$sGrowthStage
  sGrowthStageNumber<-ALLDAYDATA$sGrowthStageNumber
  sDurationStage<-ALLDAYDATA$sDurationStage
  cDeltaThermalUnit<-(ALLDAYDATA$pTopt1dev - ALLDAYDATA$pTbasedev)
  cDeltaBiologicalDay<-ALLDAYDATA$cDeltaBiologicalDay
  
  cDailyVernalization<-ALLDAYDATA$cDailyVernalization
  sVernalization <- ALLDAYDATA$sVernalization
  cCoefVernalization <- ALLDAYDATA$cCoefVernalization
  cCrownTemp <- ALLDAYDATA$cCrownTemp
  cCoefWaterstressDevelopment <- ALLDAYDATA$cCoefWaterstressDevelopment
  cTemp<-ALLDAYDATA$cTemp
  cCoefTemp <-ALLDAYDATA$cCoefTemp
  cCoefPhotoPeriod <- ALLDAYDATA$cCoefPhotoPeriod
  cPhotoDuration<-ALLDAYDATA$cPhotoDuration
  cCoefDrySoilSurface <- ALLDAYDATA$cCoefDrySoilSurface
  
  ###Vernalization
  resultfilterBD<-applyfilters("vernalisation_onBD")
  resultfilterTU<-applyfilters("vernalisation_onTU")
  resultfilter<-resultfilterBD | resultfilterTU
  if(any(resultfilter)) {
    cCrownTemp[resultfilter] <- fComputeCrownTemperature(sSnow=ALLDAYDATA$sSnow[resultfilter],
                                           iTASMax=ALLDAYDATA$iTASMax[resultfilter],
                                           iTASMin=ALLDAYDATA$iTASMin[resultfilter])
    cDailyVernalization[resultfilter] <- fComputeDailyVernalization(cCrownTemp=cCrownTemp[resultfilter],
                                                      TbaseVernalization=ALLDAYDATA$pTbaseVernalization[resultfilter],
                                                      Topt1Vernalization=ALLDAYDATA$pTopt1Vernalization[resultfilter],
                                                      Topt2Vernalization=ALLDAYDATA$pTopt2Vernalization[resultfilter],
                                                      TstopVernalization=ALLDAYDATA$pTstopVernalization[resultfilter]
    )
    sVernalization[resultfilter] <- sVernalization[resultfilter] + cDailyVernalization[resultfilter]
    #icicici there are hard-coded parameters here
    autumnheatwave<- (!is.na(sVernalization) & sVernalization < 10 & ALLDAYDATA$iTASMax > 30)
    sVernalization[autumnheatwave] <- (
      sVernalization[autumnheatwave] - 0.5 * (ALLDAYDATA$iTASMax[autumnheatwave] - 30)
    )
    sVernalization[sVernalization < 0] <- 0
    cCoefVernalization[resultfilter] <- fComputeCoefVernalization(VernalizationSensitivity=ALLDAYDATA$pVernalizationSensitivity[resultfilter],
                                                    VDSAT=ALLDAYDATA$pVDSAT[resultfilter],
                                                    sVernalization=sVernalization[resultfilter])
    #modify DTU and bd accordingly
    cDeltaThermalUnit[resultfilterTU]<-cDeltaThermalUnit[resultfilterTU]*cCoefVernalization[resultfilterTU]
    cDeltaBiologicalDay[resultfilterBD]<-cDeltaBiologicalDay[resultfilterBD]*cCoefVernalization[resultfilterBD]
  }
  
###Waterstress
  resultfilterBD<-applyfilters("waterstress_onBD")
  resultfilterTU<-applyfilters("waterstress_onTU")
  resultfilter<-resultfilterBD | resultfilterTU
  if(any(resultfilter)) {
    #modify DTU and bd accordingly
    cDeltaThermalUnit[resultfilterTU]<-cDeltaThermalUnit[resultfilterTU]*cCoefWaterstressDevelopment[resultfilterTU]
    cDeltaBiologicalDay[resultfilterBD]<-cDeltaBiologicalDay[resultfilterBD]*cCoefWaterstressDevelopment[resultfilterBD]
  }

###temperature
  resultfilterBD<-applyfilters("temperature_onBD")
  resultfilterTU<-applyfilters("temperature_onTU")
  resultfilter<-resultfilterBD | resultfilterTU
  if(any(resultfilter)){
    cTemp[resultfilter]<-fComputeTemp(tasmax=ALLDAYDATA$iTASMax[resultfilter],
                        tasmin=ALLDAYDATA$iTASMin[resultfilter])
    cCoefTemp[resultfilter]<-fComputeCoefTemp(cTemp=cTemp[resultfilter],
                                              Tbase=ALLDAYDATA$pTbasedev[resultfilter],
                                              Topt1=ALLDAYDATA$pTopt1dev[resultfilter],
                                              Topt2=ALLDAYDATA$pTopt2dev[resultfilter],
                                              Tstop=ALLDAYDATA$pTstopdev[resultfilter])
    #modify DTU and bd accordingly
    cDeltaThermalUnit[resultfilterTU]<-cDeltaThermalUnit[resultfilterTU]*cCoefTemp[resultfilterTU]
    cDeltaBiologicalDay[resultfilterBD]<-cDeltaBiologicalDay[resultfilterBD]*cCoefTemp[resultfilterBD]
  }
  
###PhotoPeriod
  resultfilterBD<-applyfilters("photoperiod_onBD")
  resultfilterTU<-applyfilters("photoperiod_onTU")
  resultfilter<-resultfilterBD | resultfilterTU
  if(any(resultfilter)){
    cPhotoDuration[resultfilter]<-fPhotoperiodDuration(iDate=ALLDAYDATA[1,"iDate"],
                                                       latitude=PARAMSIM$cases[resultfilter, "lat"])
    cCoefPhotoPeriod[resultfilter]<-fComputeCoefPhotoperiodCrops(pPhotoperiodFunction=ALLDAYDATA$pPhotoperiodFunction,
                                                                 photoDuration=cPhotoDuration,
                                                                 CriticalPhotoPeriod=ALLDAYDATA$pCriticalPhotoPeriod,
                                                                 PhotoPeriodSensitivity=ALLDAYDATA$pPhotoPeriodSensitivity
    )[resultfilter] #warning: we have to compute this for all cases, even for cases that don't need the photoperiod,
    #because in case pPhotoperiodFunction is rComputeCoefPhotoperiodMaize, it accesses ALLDAYDATA, 
    #without knowing which cases it applies to
    #modify DTU and bd accordingly
    cDeltaThermalUnit[resultfilterTU]<-cDeltaThermalUnit[resultfilterTU]*cCoefPhotoPeriod[resultfilterTU]
    cDeltaBiologicalDay[resultfilterBD]<-cDeltaBiologicalDay[resultfilterBD]*cCoefPhotoPeriod[resultfilterBD]
  }
  
###dry Soil Surface
  resultfilterBD<-applyfilters("drySoilSurface_onBD")
  resultfilterTU<-applyfilters("drySoilSurface_onTU")
  resultfilter<-resultfilterBD | resultfilterTU
  if(any(resultfilter)) {
    FTSW.1<-fFindWater(layers=1, df=ALLDAYDATA, what="FTSW")
    cCoefDrySoilSurface[resultfilter & FTSW.1<=0]<-0
    #modify DTU and bd accordingly
    cDeltaThermalUnit[resultfilterTU]<-cDeltaThermalUnit[resultfilterTU]*cCoefDrySoilSurface[resultfilterTU]
    cDeltaBiologicalDay[resultfilterBD]<-cDeltaBiologicalDay[resultfilterBD]*cCoefDrySoilSurface[resultfilterBD]
  }
  
###Phenology Update
  sThermalUnit[cultivars!="NA.NA"]<-(sThermalUnit + cDeltaThermalUnit)[cultivars!="NA.NA"]
  sBiologicalDay[cultivars!="NA.NA"]<-(sBiologicalDay + cDeltaBiologicalDay)[cultivars!="NA.NA"]
  sBiologicalDaysSinceSowing[cultivars!="NA.NA"]<-(sBiologicalDaysSinceSowing + cDeltaBiologicalDay)[cultivars!="NA.NA"]
  
####stage changes
  changestage<-sBiologicalDay>sDurationStage
  changestage[is.na(changestage)]<-FALSE
  if(any(changestage)) {
    sGrowthStageNumber[changestage]<-sGrowthStageNumber[changestage]+1
    #find the corresponding stage name
    sGrowthStage[changestage]<-mapply(function(thresh, num) return(names(thresh)[num]),
                                      ALLCROPS[cultivars[changestage], "thresholds"], 
                                      sGrowthStageNumber[changestage]
    )
    #find the corresponding stage duration
    DurationNextStage<-mapply(function(cropname, stage) return(ALLCROPS[cropname,"thresholds"][[1]][stage]),
                        cultivars[changestage], 
                        as.character(sGrowthStage)[changestage], SIMPLIFY = TRUE, USE.NAMES=FALSE
                        )
    # when the stage changes, we start the counter with the remaining of increment-threshold (but not for TU)
    sBiologicalDay[changestage]<-sBiologicalDay[changestage]-sDurationStage[changestage] #if we change stages, we start not from 0 but from the "extra units accuulated during the timestep
    #and we update the stage duration with the duration of nextstage
    sDurationStage[changestage]<-DurationNextStage
    #and we update it again by parsing the actionsAtStageChange that correspond to the cultivars that changed and the corresponding stages
    actionstodo<-mapply(function(cropname, stage) return(ALLCROPS[cropname,"actionsAtStageChange"][[1]][stage]),
                               cultivars, 
                               as.character(sGrowthStage), SIMPLIFY = TRUE, USE.NAMES=FALSE
    )
    #we don't do the actions now, first we update ALLDAYDATA because actionstodo are procedures that directly modify ALLDAYDATA
  } else actionstodo<-list()
  
####Update ALLDAYDATA
  ALLDAYDATA[,c("sThermalUnit", "sBiologicalDay", "sBiologicalDaysSinceSowing", "sGrowthStage", "sGrowthStageNumber", "sDurationStage", "sVernalization",
                "cDeltaThermalUnit", "cDeltaBiologicalDay", "cDailyVernalization", "cCoefVernalization", "cCrownTemp", 
                "cTemp", "cCoefTemp", "cCoefPhotoPeriod", "cPhotoDuration", "cCoefDrySoilSurface")]<<-data.frame(
                  sThermalUnit, sBiologicalDay, sBiologicalDaysSinceSowing, sGrowthStage, sGrowthStageNumber, sDurationStage, sVernalization,
                  cDeltaThermalUnit, cDeltaBiologicalDay, cDailyVernalization, cCoefVernalization, cCrownTemp, 
                  cTemp, cCoefTemp, cCoefPhotoPeriod, cPhotoDuration, cCoefDrySoilSurface  )
  ##### do actionstodo
  for (atd in unique(actionstodo[!is.na(actionstodo) & !sapply(actionstodo, is.null)])) {
    whichcases<-(!is.na(actionstodo) &  !sapply(actionstodo, is.null) & actionstodo==atd) 
    do.call(atd, list(whichcases=whichcases))
  }
}

#####LAI module
rUpdateLAI<-function(){
  #print("Updating LAI")
  cultivars<-paste(ALLDAYDATA$sCrop, ALLDAYDATA$sCultivar, sep=".")
  sMainstemNodeNumber<-ALLDAYDATA$sMainstemNodeNumber
  sPlantLeafArea<-ALLDAYDATA$sPlantLeafArea
  cGrowthLAI<-ALLDAYDATA$cGrowthLAI
  sDecreaseLAIperBD<-ALLDAYDATA$sDecreaseLAIperBD #simple decrease rate that remains the same throughout leaf senescence, to arrive at 0 LAI at MAT
  sLAIforEvapotranspiration<-ALLDAYDATA$sLAIforEvapotranspiration #we need to keep this information because it is used for evapotranspiration
  sLAI<-ALLDAYDATA$sLAI
  ###LAI Growing (similar with and without N contribution)
  #LAIMainstem (i.e.between bdBLG and bdTLM)
  cCoefWaterstressLeafArea<-ALLDAYDATA$cCoefWaterstressLeafArea
  daily_increase_node_number <- ALLDAYDATA$sThermalUnit / ALLDAYDATA$pPhyllochron 
  sMainstemNodeNumber[!is.na(daily_increase_node_number)] <- (ALLDAYDATA$sMainstemNodeNumber  + daily_increase_node_number)[!is.na(daily_increase_node_number)]
  leaf_area_yesterday<-ALLDAYDATA$sPlantLeafArea
  LAI_yesterday<-ALLDAYDATA$sLAI
  toto<-ALLDAYDATA$pcoefPlantLeafNumberNode * sMainstemNodeNumber ^ ALLDAYDATA$pExpPlantLeafNumberNode
  sPlantLeafArea[!is.na(toto)] <- toto[!is.na(toto)]
  
  #Mainstem
  increase_LAIMainstem <- rep(0, nrow(ALLDAYDATA))
  resultfilter<-applyfilters("LAI_Mainstem")
  if(any(resultfilter)) {
    increase_LAIMainstem[resultfilter] <- ((
      (sPlantLeafArea - leaf_area_yesterday) * ALLDAYDATA$sPlantdensity / 10000) 
      * ALLDAYDATA$cCoefWaterstressLeafArea
    )[resultfilter]
  }
  
  #LAISecondary (between booting and beginning of seed growth for wheat, between bdTLM and bdTLP for legumes)
  increase_LAISecondary <- rep(0, nrow(ALLDAYDATA))
  resultfilter<-applyfilters("LAI_Secondary")
  if(any(resultfilter)) {
    increase_LAISecondary[resultfilter] <- (ALLDAYDATA$sDailyLeafWeightIncrease * ALLDAYDATA$pSpecificLeafArea)[resultfilter] #sDailyLeafWeightIncrease = GLF from yesterday, from module DM_Distribution
  }
  #LAI Total Growing
  cGrowthLAI[cultivars != "NA.NA"]<- (increase_LAIMainstem + increase_LAISecondary )[cultivars != "NA.NA"]
  
  ###LAI Decrease
  cDecreaseLAI<-rep(0, nrow(ALLDAYDATA))
  if(PARAMSIM$Neffect==T){
    #icicici not done yet, need to do it after Plant N module is coded
    cDecreaseLAI<-fComputeDecreaseLAIwithN(DailyRateNfromLeave=ALLDAYDATA$sDailyRateNfromLeave, #XNLF from yesterday, from module PlantN
                                           SpecLeafNGreenLeaf=ALLDAYDATA$pSpecLeafNGreenLeaf,
                                           SpecLeafNSenescenceLeaf=ALLDAYDATA$pSpecLeafNSenescenceLeaf)
  }else{ #LAI decrease following a straight line from LAI at beginning of senescence to 0 at MAT (=last stage in all crops)
    #the computation is more complicated than in the excel version, because we want to have nothing hard-coded (except that MAT is the last before last stage in the vector of stages)
    #and we didn't want to asking the user to add an extra parameter for senescence duration
    resultfilter<-applyfilters("LAI_Senescence")
    sLAIforEvapotranspiration[!resultfilter]<-LAI_yesterday[!resultfilter] #before senescence, we use the LAI (after, it will allways remain the same)
    if(any(resultfilter)) {
      startsenescence<-resultfilter & sDecreaseLAIperBD==0 #cases where we just started leaf senescence (sDecreaseLAIperBD was still at its initial value)
      if (any(startsenescence)) {
        BLSLAI<-rep(NA, nrow(ALLDAYDATA))
        BLSLAI[startsenescence]<-LAI_yesterday[startsenescence] #LAI at start of senescence
        cultivars_startsenescence<-paste(ALLDAYDATA$sCrop,ALLDAYDATA$sCultivar, sep=".")[startsenescence]
        durationOtherstages<-numeric()
        for (cr in unique(cultivars_startsenescence)) { #for each cultivar, we will find the duration of remaining stages after the current one
          currentstageNumber<-ALLDAYDATA$sGrowthStageNumber[startsenescence & paste(ALLDAYDATA$sCrop,ALLDAYDATA$sCultivar, sep=".")==cr][1] #they are all the same, because the filter for senescence is defined at the crop-cultivar level
          durationstages<-ALLCROPS[cr, "thresholds"][[1]]
          if(is.finite(durationstages[length(durationstages)])) warning(paste("leaf senescence (in the case where PARAMSIM$Neffect is FALSE) expects that the vector of thresholds for the different stages of the crops ends with a 'fake' last stage with length Inf. It is not the case for crop", cr,"so the last stage is not included in senescence" ))
          durationremainingstages<-sum(durationstages[(currentstageNumber+1):(length(durationstages)-1)]) #duration of all the other stages NOT including the current one, and of course not including the "fake" last stage with length Inf
          names(durationremainingstages)<-cr
          durationOtherstages<-c(durationOtherstages, durationremainingstages)
          if(is.na(durationremainingstages)) stop(paste("the duration of leaf senescence for", cr, " cannot be computed due to some stages having variable duration, this is not allowed in this version of the model"))
        }
        bdToMAT<-rep(NA, nrow(ALLDAYDATA)) #number of biological days from start of senescence to end of last stage
        bdToMAT[startsenescence]<-(ALLDAYDATA$sDurationStage[startsenescence] - ALLDAYDATA$sBiologicalDay[startsenescence]
        ) + ( #remaining duration of the current stage
          durationOtherstages[cultivars_startsenescence]
        )
        sDecreaseLAIperBD[startsenescence]<-BLSLAI[startsenescence]/bdToMAT[startsenescence]
      }
      cDecreaseLAI[resultfilter]<-sDecreaseLAIperBD[resultfilter]*ALLDAYDATA$cDeltaBiologicalDay[resultfilter]
    }
  }

   cFrost<-fFrostEffect(LAI=LAI_yesterday,tasmin=ALLDAYDATA$iTASMin,
                       FreezeThresholdTemp=ALLDAYDATA$pFreezeThresholdTemp,
                       FreezeFracLeafDestruction=ALLDAYDATA$pFreezeFracLeafDestruction)
   cHeat<-fHeatEffectSemenovSirius(
        cDecreaseLAI,tasmax=ALLDAYDATA$iTASMax, HeatThresholdTemp=ALLDAYDATA$pHeatThresholdTemp,
        HeatFracLeafDestruction=ALLDAYDATA$pHeatFracLeafDestruction)
   #just in case we want to add a parameter in the crop file to select the type of LAI decrease response to heat
   # cHeat<-rep(0, nrow(ALLDAYDATA))
   # cHeat[ALLDAYDATA$pHeateffectfunction=="SemenovSirius"]<- fHeatEffectSemenovSirius(
   #   cDecreaseLAI,tasmax=ALLDAYDATA$iTASMax, HeatThresholdTemp=ALLDAYDATA$pHeatThresholdTemp,
   #   HeatFracLeafDestruction=ALLDAYDATA$pHeatFracLeafDestruction)[ALLDAYDATA$pHeateffectfunction=="SemenovSirius"]
   # cHeat[ALLDAYDATA$pHeateffectfunction=="AssengAPSIM"]<- fHeatEffectAssengAPSIM(
   #   cDecreaseLAI,tasmax=ALLDAYDATA$iTASMax, HeatThresholdTemp=ALLDAYDATA$pHeatThresholdTemp,
   #   HeatFracLeafDestruction=ALLDAYDATA$pHeatFracLeafDestruction)[ALLDAYDATA$pHeateffectfunction=="SemenovSirius"]
   cDecreaseLAI<-pmax(cFrost,cHeat)   
   ####heat LAI corresponds to cDecreaseLAI if no heat effect 
   # and cDreaseLAI corresponds to heat if hot effet. 
   #Take effect of frost if it is more important that cDecreaseLAI

  sLAI[cultivars != "NA.NA"] <- pmax(0, ALLDAYDATA$sLAI+cGrowthLAI-cDecreaseLAI)[cultivars != "NA.NA"]         #Update LAI (sLAI) by the end of the module (in SSM excel is in the beginning)

  ####Mortality test with low LAI CONDITION moved to DMDistribution
  #alaicond<-applyfilters("DMDistribution_SeedGrowing")
  #cEndCropCycle<-ifelse((sLAI< 0.05 & alaicond==TRUE),"pre-mature due to low LAI",NA)

  ALLDAYDATA[,c("sMainstemNodeNumber",
                "sPlantLeafArea",
                "cGrowthLAI",
                "sDecreaseLAIperBD",
                "sLAIforEvapotranspiration",
                "cDecreaseLAI",
                "cFrost",
                "cHeat",
                "sLAI")]<<-data.frame(
                  sMainstemNodeNumber,
                  sPlantLeafArea,
                  cGrowthLAI,
                  sDecreaseLAIperBD,
                  sLAIforEvapotranspiration,
                  cDecreaseLAI,
                  cFrost,
                  cHeat,
                  sLAI)
}


##### DM Production module
rUpdateDMProduction<-function(){
  #print("Updating DMProduction")
  cRUE <- rep(0, nrow(ALLDAYDATA))   #Radiation efficiency is null when the plant doens't produce leaf
  cCoefTemperatureRUE <- ALLDAYDATA$cCoefTemperatureRUE
  cCoefWaterstressGrowth<-ALLDAYDATA$cCoefWaterstressGrowth
  cPAR<-ALLDAYDATA$cPAR
  cDryMatterProduction<-ALLDAYDATA$cDryMatterProduction
  aFINT<-rep(0, nrow(ALLDAYDATA)) 
  resultfilter<-applyfilters("DMProduction") 
  if(any(resultfilter)) {
    cCoefTemperatureRUE[resultfilter]<-fComputeCoefTemp(cTemp=ALLDAYDATA$cTemp,Tbase=ALLDAYDATA$pTbaseRUE,
                                                             Topt1=ALLDAYDATA$pTopt1RUE,
                                                             Topt2=ALLDAYDATA$pTopt2RUE,
                                                             Tstop=ALLDAYDATA$pTstopRUE)[resultfilter]
    cRUE[resultfilter] <- (ALLDAYDATA$pRadEffiencyOptimal * cCoefTemperatureRUE * cCoefWaterstressGrowth)[resultfilter]
    cPAR[resultfilter]<-fComputePAR(globalradiation=ALLDAYDATA$iRSDS, 
                                    CoefPAR=GENERALPARAMETERS["pCoefPAR", "defaultInitialvalue"])[resultfilter]
    aFINT[resultfilter]<- (1 - exp(-ALLDAYDATA$pKPAR * ALLDAYDATA$sLAI))[resultfilter]
    cDryMatterProduction[resultfilter] <- (cPAR * aFINT * cRUE)[resultfilter]
  }
  
  ALLDAYDATA[,c("cCoefTemperatureRUE","cRUE","cPAR","cDryMatterProduction")]<<-data.frame(
    cCoefTemperatureRUE,cRUE,cPAR,cDryMatterProduction)

}


#### DM DIstribution module
rUpdateDMDistribution<-function(){
  #icicici warning: this procedure is a simple translation of the VBA code, which does not correspond to what 
  #is described in the book, for example it does not take into acount tuBSG and tuTSG
  
  #local copy of all variables that are needed
  #crop parameters (not to be saved)
  pFractionCropMassTranslocatable<-ALLDAYDATA$pFractionCropMassTranslocatable #FRTRL
  pGrainConversionCoefficient<-ALLDAYDATA$pGrainConversionCoefficient #GCC
  pFractionDMtoLeavesPhase1A<-ALLDAYDATA$pFractionDMtoLeavesPhase1A #FLF1A
  pFractionDMtoLeavesPhase1B<-ALLDAYDATA$pFractionDMtoLeavesPhase1B #FLF1B
  pFractionDMtoLeavesPhase2<-ALLDAYDATA$pFractionDMtoLeavesPhase2 #FLF2
  pPotentialDailyRateHIincrease<-ALLDAYDATA$pPotentialDailyRateHIincrease #PDHI
  pDailyRateHIincreaseCriticalPoint1<-ALLDAYDATA$pDailyRateHIincreaseCriticalPoint1 #WDHI1
  pDailyRateHIincreaseCriticalPoint2<-ALLDAYDATA$pDailyRateHIincreaseCriticalPoint2 #WDHI2
  pDailyRateHIincreaseCriticalPoint3<-ALLDAYDATA$pDailyRateHIincreaseCriticalPoint3 #WDHI3
  pDailyRateHIincreaseCriticalPoint4<-ALLDAYDATA$pDailyRateHIincreaseCriticalPoint4 #WDHI4
  pInflexionPointLeafAllocationAB<-ALLDAYDATA$pInflexionPointLeafAllocationAB #WTOPL
  pStemMinimumNconcentration<-ALLDAYDATA$pStemMinimumNconcentration #SNCS
  #state and computed variables from this module (to be saved)
  cDailyDryMatterforLeavesAndStems<-ALLDAYDATA$cDailyDryMatterforLeavesAndStems #DDMP2
  sDailyLeafWeightIncrease<-ALLDAYDATA$sDailyLeafWeightIncrease #GLF
  cDailyPortionDMtranslocated<-ALLDAYDATA$cDailyPortionDMtranslocated #TRANSL
  cDailySeedWeightIncrease<-ALLDAYDATA$cDailySeedWeightIncrease #SGR
  cDailyStemWeightIncrease<-ALLDAYDATA$cDailyStemWeightIncrease #GST
  cEffectOfHeatOnDHI<-ALLDAYDATA$cEffectOfHeatOnDHI #FrHtDHI
  cFractionDMtoLeaves<-ALLDAYDATA$cFractionDMtoLeaves #FLF
  sAccumulatedAboveGroundDryMatter<-ALLDAYDATA$sAccumulatedAboveGroundDryMatter #WTOP
  sAccumulatedGrainDryMatter<-ALLDAYDATA$sAccumulatedGrainDryMatter #WGRN
  sAccumulatedLeafDryMatter<-ALLDAYDATA$sAccumulatedLeafDryMatter #WLF
  sAccumulatedStemDryMatter<-ALLDAYDATA$sAccumulatedStemDryMatter #WST
  sAccumulatedVegetativeDryMatter<-ALLDAYDATA$sAccumulatedVegetativeDryMatter #WVEG
  sDailyRateHIincrease<-ALLDAYDATA$sDailyRateHIincrease #DHI
  sDryMatterAtBeginningSeedGrowth<-ALLDAYDATA$sDryMatterAtBeginningSeedGrowth #BSGDM
  sHarvestIndex<-ALLDAYDATA$sHarvestIndex #HI
  sTranslocatableBiomass<-ALLDAYDATA$sTranslocatableBiomass #TRLDM
  #state variables from other modules (not to be saved)
  cultivars<-paste(ALLDAYDATA$sCrop, ALLDAYDATA$sCultivar, sep=".")
  DryMatterProduction<-ALLDAYDATA$cDryMatterProduction #DDMP of today, from DMProduction module
  LAI<-ALLDAYDATA$sLAI #LAI of today, from LAI module
  Nstem<-ALLDAYDATA$sNstem # NST of yesterday, from PlantN module (which updates it later)
  
  
  #seed growth
  phaseSeedGrowth<-applyfilters("DMDistribution_SeedGrowing")
      # things to do before seed growth so that some variables are initialized at their value at beginning of seed growth 
      # (these could be replaced by an actionsAtStageChange, but it would mean that beginning of seed growth has to be explicitely defined as a stage change, which is not the case in the initial crop files for wheat (ANT+5) and maize (SIL+170/effT))
  sDryMatterAtBeginningSeedGrowth[!phaseSeedGrowth]<-sAccumulatedAboveGroundDryMatter[!phaseSeedGrowth] #Saving WTOP at BSG because this stops being overwritten by abovegroundDM (thus remains at its value from yesterday) as soon as seed growth begins
  sDailyRateHIincrease[!phaseSeedGrowth]<-fFunctionstep(x=sDryMatterAtBeginningSeedGrowth, 
                                      x1=pDailyRateHIincreaseCriticalPoint1,
                                      x2=pDailyRateHIincreaseCriticalPoint2,
                                      x3=pDailyRateHIincreaseCriticalPoint3,
                                      x4=pDailyRateHIincreaseCriticalPoint4,
                                      y1=0,
                                      y2=pPotentialDailyRateHIincrease,
                                      y3=0)[!phaseSeedGrowth]
  sTranslocatableBiomass[!phaseSeedGrowth]<-(sDryMatterAtBeginningSeedGrowth*pFractionCropMassTranslocatable)[!phaseSeedGrowth]
  
  #compute first version of seed growth rate
  ## icicici cEffectOfHeatOnDHI (FrHtDHI) is never changed in the code, it is always 1
  ## icicici I don't understand this equation : it seems to me DryMatterProduction is added twice: 
  cDailySeedWeightIncrease[phaseSeedGrowth]<-pmax(0, ((sDailyRateHIincrease*cEffectOfHeatOnDHI) # coefficient that is a function of DryMatterAtBeginningSeedGrowth
                             *(sAccumulatedAboveGroundDryMatter + DryMatterProduction) # accumulated DM until today (included)
                             + DryMatterProduction*sHarvestIndex)[phaseSeedGrowth]) #dry matter produced today * harvest index of yesterday
  
  #if there is no N for seed filling (can happen with option Neffect=TRUE (LAI_N)), no seed growth
  cDailySeedWeightIncrease[phaseSeedGrowth & LAI==0 & Nstem <= (sAccumulatedStemDryMatter * pStemMinimumNconcentration)]<-0
  
  #translocation (remobilization of DM from stem and leaves to seed)
  cDailyPortionDMtranslocated[phaseSeedGrowth]<-pmax(0, pmin(sTranslocatableBiomass[phaseSeedGrowth], (cDailySeedWeightIncrease/pGrainConversionCoefficient-DryMatterProduction)[phaseSeedGrowth]))
  sTranslocatableBiomass[phaseSeedGrowth]<-(sTranslocatableBiomass-cDailyPortionDMtranslocated)[phaseSeedGrowth]
  cDailySeedWeightIncrease[phaseSeedGrowth]<-pmin(cDailySeedWeightIncrease, 
                                                  (DryMatterProduction+cDailyPortionDMtranslocated)*pGrainConversionCoefficient)[phaseSeedGrowth]
  #dry matter available for leaves and stems
  cDailyDryMatterforLeavesAndStems<-pmax(0, DryMatterProduction-cDailySeedWeightIncrease*pGrainConversionCoefficient)
  
  #select the cFractionDMtoLeaves corresponding to the phase
  phase1A<-applyfilters("LAI_Mainstem") & sAccumulatedAboveGroundDryMatter<pInflexionPointLeafAllocationAB
  phase1B<-applyfilters("LAI_Mainstem") & sAccumulatedAboveGroundDryMatter>=pInflexionPointLeafAllocationAB
  phase2<-applyfilters("LAI_Secondary")
  phaseVegetativeGrowth<- (phase1A | phase1B | phase2)
  cFractionDMtoLeaves[phase1A]<-pFractionDMtoLeavesPhase1A[phase1A]
  cFractionDMtoLeaves[phase1B]<-pFractionDMtoLeavesPhase1B[phase1B]
  cFractionDMtoLeaves[phase2]<-pFractionDMtoLeavesPhase2[phase2]
  
  #distribution of DM between leaves and stem
  sDailyLeafWeightIncrease[phaseVegetativeGrowth]<- (cFractionDMtoLeaves*cDailyDryMatterforLeavesAndStems)[phaseVegetativeGrowth]
  cDailyStemWeightIncrease[phaseVegetativeGrowth]<-((1-cFractionDMtoLeaves)*cDailyDryMatterforLeavesAndStems)[phaseVegetativeGrowth]
  
  #Organs accumulated mass
  withcrop<- (cultivars != "NA.NA")
  sAccumulatedLeafDryMatter[withcrop]<-(sAccumulatedLeafDryMatter + sDailyLeafWeightIncrease)[withcrop]
  sAccumulatedStemDryMatter[withcrop]<-(sAccumulatedStemDryMatter + cDailyStemWeightIncrease)[withcrop]
  sAccumulatedVegetativeDryMatter[withcrop]<-(sAccumulatedVegetativeDryMatter + cDailyDryMatterforLeavesAndStems)[withcrop]
  sAccumulatedGrainDryMatter[withcrop]<-(sAccumulatedGrainDryMatter + cDailySeedWeightIncrease)[withcrop]
  sAccumulatedAboveGroundDryMatter[withcrop]<-(sAccumulatedVegetativeDryMatter + sAccumulatedGrainDryMatter)[withcrop]
  sHarvestIndex[withcrop]<-(sAccumulatedGrainDryMatter/sAccumulatedAboveGroundDryMatter)[withcrop]
  
  #saving state and computed variables
  ALLDAYDATA[,c("cDailyDryMatterforLeavesAndStems", "sDailyLeafWeightIncrease", "cDailyPortionDMtranslocated",
               "cDailySeedWeightIncrease", "cDailyStemWeightIncrease", "cEffectOfHeatOnDHI", "cFractionDMtoLeaves",
               "sAccumulatedAboveGroundDryMatter", "sAccumulatedGrainDryMatter", "sAccumulatedLeafDryMatter", 
               "sAccumulatedStemDryMatter", "sAccumulatedVegetativeDryMatter", "sDailyRateHIincrease", 
               "sDryMatterAtBeginningSeedGrowth", "sHarvestIndex", "sTranslocatableBiomass")]<<-data.frame(
                 cDailyDryMatterforLeavesAndStems, sDailyLeafWeightIncrease, cDailyPortionDMtranslocated,
                 cDailySeedWeightIncrease, cDailyStemWeightIncrease, cEffectOfHeatOnDHI, cFractionDMtoLeaves, 
                 sAccumulatedAboveGroundDryMatter, sAccumulatedGrainDryMatter, sAccumulatedLeafDryMatter, 
                 sAccumulatedStemDryMatter, sAccumulatedVegetativeDryMatter, sDailyRateHIincrease,
                 sDryMatterAtBeginningSeedGrowth, sHarvestIndex, sTranslocatableBiomass
               )
    
    
}


####root depth module
rUpdateRootDepth<-function(){
  filter<-applyfilters("rRootDepth") #filter on stage (crop parameter)
  if (any(filter)){
    grtd<-ALLDAYDATA$cDeltaBiologicalDay*ALLDAYDATA$pPotentialRootGrowth #potential growth
    grtd<-grtd*filter #filter on stage (crop parameter)
    grtd[ALLDAYDATA$cDryMatterProduction==0 #in case no biomass accumulation
         | ALLDAYDATA$sRootFrontDepth>=ALLDAYDATA$pMaxDepthWaterExtraction #or root depth already at the maximum water extraction depth
         | ALLDAYDATA$sRootFrontDepth>=fExtractSoilParameter("pLayerThickness", Inf, "sum", na.rm=TRUE) #or root already at hte bottom of the soil
         ]<-0 #then no root growth
    rtln<-mapply(function(floors,rootdepths) {toto<-which.max(floors[floors<rootdepths])+1 ; if(length(toto)==0) toto<-1; return(toto)},
                 as.data.frame(t(fExtractSoilParameter("pLayerThickness", Inf, "cumsum"))), #lignes: cases, colonnes: profondeurs du plancher de chaque couche
                 ALLDAYDATA$sRootFrontDepth #vecteur (cases) de profondeur de racines
    ) #vector (one element per case) of number of the lowest layer with roots
    grtd[fFindWater(layer=rtln, what="ATSW", df=ALLDAYDATA)==0]<-0 #in case the lowest layer with roots (=the layer of root tips) is dry, no growth
    ALLDAYDATA$sRootFrontDepth<<-ALLDAYDATA$sRootFrontDepth+grtd
  }
}


#### Water module
rUpdateWaterBudget<-function(){
  #we transform all variables into matrices (rows = cases, columns= layers) to facilitate computations
  sWater<-as.matrix(ALLDAYDATA[,paste("sWater", 1:10, sep=".")])
  
  #icicicic warning  : rootLength_L here is computed after today's root growth,
  # while cAvailableWaterInRootZone (AROOT) was computed with root length from the day before in rUpdateStresses
  # and waterStressTranspiration_L is also from yesterday variables (FTSW_L is computed at the beginning of the current procedure, and does not weight by root length
  #check in the excel code when each element is updated to do the same
  yesterdayFTSWweightedByRoots<- ALLDAYDATA$cFTSWrootZone #FTSWRZ (computed in rUpdateStresses)
  yesterdayEfficientRootLength<- ALLDAYDATA$cAvailableWaterInRootZone #AROOT (computed in rUpdateStresses)
  FTSW_L<- fFindWater(layers=Inf, df=ALLDAYDATA, what="FTSW", weightedbyroots=FALSE) #FTSW(L)
  ATSW_1<- fFindWater(layers=1, df=ALLDAYDATA, what="ATSW")
  WLUL_L<- fExtractSoilParameter(paramname="pFieldCapacity", Inf)*fExtractSoilParameter(paramname="pLayerThickness", Inf) #water amount above the field capacity
  waterStressTranspiration_L<- pmax(pmin(FTSW_L/ALLDAYDATA$pThresholdWaterStressGrowth, 1),0 ) #RT(L)
  sDaysSinceStage2evaporation<-ALLDAYDATA$sDaysSinceStage2evaporation
  rootLength_L<-fFindRLYER(Inf, ALLDAYDATA) #RLYER with root length of today !!
  cTranspiration<-ALLDAYDATA$cTranspiration
  cultivars<-paste(ALLDAYDATA$sCrop, ALLDAYDATA$sCultivar, sep=".")
  
  cIrrigationWater<-ALLDAYDATA$cIrrigationWater
  
  #input rain+melted snow
  rain<-ALLDAYDATA[,"cPrCorrected"]
  
  #drainage has been moved to after computation of FLOUT (it is just for saving the amount of water drained, can be done at the end of the procedure)
  
  #compute runoff
  cRunoff<-fComputeRunoff(vectorRain=rain,
                        vectorCurveNumber=fExtractSoilParameter("pSoilCurveNumber"), 
                        vectorSAT=fExtractSoilParameter("pSaturation", layers=1),
                        vectorLayerThickness=fExtractSoilParameter("pLayerThickness", layers=1),
                        vectorWaterContent=sWater[,1],
                        vectorWLL=fExtractSoilParameter("pWiltingPoint", layers=1)
  )
  #find LAI useful to compute soil evaporation (= real LAI until beginning of seed growth, and then LAI at stage TLP (which is not necessarily BSG))
  etlai<-ALLDAYDATA[,"sLAIforEvapotranspiration"] # icicicici BLSLAI is overwritten at different places: at beginning of leaf senescence (BLS), and at termination of secondary LAI growth (TLP).... and depending on the crop, BLS is before (legumes), after (maize) or the same (wheat) as TLP. I haven't had time to study in detail in which case BLSLAI is really at beginning of leaf senescence and in which case it isn't
  etlai[is.na(etlai)]<-0
  
  #compute PET
  cropAlbedo<-GENERALPARAMETERS["pCropAlbedo", "defaultInitialvalue"]
  canopyExtinctionCoefficient<-GENERALPARAMETERS["pCanopyExtinctionCoefficient", "defaultInitialvalue"]
  minimalSoilEvaporation<-GENERALPARAMETERS["pMinimalSoilEvaporation", "defaultInitialvalue"]
  soilWettingWaterQuantity<-GENERALPARAMETERS["pSoilWettingWaterQuantity","defaultInitialvalue"]
  cPET<-fComputePETsimplifiedPenman(tmax=ALLDAYDATA[,"iTASMax"], 
                                   tmin=ALLDAYDATA[,"iTASMin"], 
                                   srad=ALLDAYDATA[,"iRSDS"], 
                                   calb=canopyExtinctionCoefficient, 
                                   ket=canopyExtinctionCoefficient, 
                                   etlai=etlai , salb=fExtractSoilParameter("pSoilAlbedo"))
  #compute soil evaporation
  cPotentialSoilEvaporation <- cPET * exp(-canopyExtinctionCoefficient * etlai)
  cPotentialSoilEvaporation[cPET > minimalSoilEvaporation & cPotentialSoilEvaporation<minimalSoilEvaporation]<-minimalSoilEvaporation
  #modify to take into account the effect of mulch 
  #icicic this equation has hard-coded parameters
  #cPotentialSoilEvaporation <- cPotentialSoilEvaporation * (1.5 - 0.2 * log((100 * ALLDAYDATA$sStubleWeight))) #old version of SSM.xlsx
  cPotentialSoilEvaporation <- cPotentialSoilEvaporation * exp(-0.22 * ALLDAYDATA$sStubleWeight/10) #(Salado and sinclair 2013)
  
  #real soil evaporation 
  cActualSoilEvaporation<-cPotentialSoilEvaporation
  sDaysSinceStage2evaporation[rain + cIrrigationWater > soilWettingWaterQuantity]<-0
  conditionstageII<- yesterdayFTSWweightedByRoots<=0.5 | ATSW_1<=1
  cActualSoilEvaporation[conditionstageII]<-(cActualSoilEvaporation*((sDaysSinceStage2evaporation+1)^0.5-sDaysSinceStage2evaporation^0.5))[conditionstageII]
  sDaysSinceStage2evaporation[conditionstageII]<-sDaysSinceStage2evaporation[conditionstageII]+1 
  
  #plant transpiration
  #icicici this equation contains hard-coded parameters
  VPTMIN<- 0.6108 * exp(17.27 * ALLDAYDATA$iTASMin / (ALLDAYDATA$iTASMin + 237.3))
  VPTMAX<- 0.6108 * exp(17.27 * ALLDAYDATA$iTASMax / (ALLDAYDATA$iTASMax + 237.3))
  VPD <- fExtractSoilParameter(paramname="pVPDcoef") * (VPTMAX - VPTMIN) #warning: in SSM.R, VPDF (and latitude) has been moved from location-specific parameters to soil parameters, to avoid having a file just for locations
  cTranspiration[cultivars != "NA.NA"] <- pmax(0, ALLDAYDATA$cDryMatterProduction * VPD / ALLDAYDATA$pTranspirationEfficiencyLinkedToCO2)[cultivars != "NA.NA"] #icicicic VPD in kPa, TEC in Pa
  
  #compute water uptake
  WUUR<-cTranspiration/(yesterdayEfficientRootLength + 1e-8) 
  waterUptake_L<-rootLength_L*waterStressTranspiration_L*WUUR
  waterUptake_L[is.na(waterUptake_L)] <-0
  
  #distribute soil evaporation in different soil layers
  soilEvaporation_L<-matrix(0, nrow=nrow(PARAMSIM$cases), ncol=10)
  WLAD_L<-fExtractSoilParameter("pSoilDryness", layers=Inf)*fExtractSoilParameter("pLayerThickness", layers=Inf)
  DRAINF_L<-fExtractSoilParameter("pDrainedFraction", layers=Inf)
  toBeEvaporated<-cActualSoilEvaporation #TSE
  for (l in 1:10) {
    evapHere<-pmax(0, pmin(toBeEvaporated, (sWater[,l]-WLAD_L[l])*DRAINF_L[l]))
    soilEvaporation_L[,l]<-evapHere
    toBeEvaporated<-pmax(0, toBeEvaporated-evapHere)
  }
  soilEvaporation_L[is.na(soilEvaporation_L)] <-0
  
  #water budget
  FLOUT<-pmax((sWater - WLUL_L)*fExtractSoilParameter(paramname="pDrainedFraction", Inf), 0) #flow of water downward
  FLIN<-matrix(0, nrow=nrow(PARAMSIM$cases), ncol=10)
  FLIN[,1]<-rain + cIrrigationWater - cRunoff
  FLIN[,2:10]<-FLOUT[,1:9]
  sWater<-sWater + FLIN - FLOUT - waterUptake_L - soilEvaporation_L
  
  #drainage
  drainLayer<-fExtractSoilParameter("pDrainLayer")
  cDrain<-FLOUT[cbind(1:nrow(FLOUT), drainLayer)]
  #update water content in each layer of soil and everything else
  ALLDAYDATA[,c(paste("sWater", 1:10, sep="."), 
                "cRunoff",
                "cPET",
                "cPotentialSoilEvaporation",
                "sDaysSinceStage2evaporation",
                "cActualSoilEvaporation",
                "cTranspiration", "cDrain")]<<-cbind(as.data.frame(sWater), data.frame(
                  cRunoff,
                  cPET,
                  cPotentialSoilEvaporation,
                  sDaysSinceStage2evaporation,
                  cActualSoilEvaporation,
                  cTranspiration, cDrain
                ))
}


rUpdateSoilNitrogen <- function (initialization = FALSE) {
  # ----- INITIALIZATION OF THE MODULE -----
  # icicici /!\ Do we have to extract parameters on every timestep or can we
  # only extract them once ? cf. changelog
  if (initialization == TRUE) {
    # ---- getting and computing parameters and inputs ----
      
    # ---- computing and saving initial values ----
      
    # ---- initialization of cumulative values ---
  }

  
  # --------------- EACH DAY ---------------
  # ---- N net mineralization ----
  # ---- N application & volatilization ----
  # ---- N downward movement ----
  # ---- N denitrification ----
  # ---- N removal by plant uptake ----
  # ---- Updating soil N balance ----
}



##### some output functions specific to SSM

fExportStageDates<-function(){
  #datestages<-data.frame(date=mExtractVariable("sGrowthStage"), crop=mExtractVariable("sGrowthStage"), stage=mExtractVariable("sGrowthStage"))
  return(data.frame(case=NA, crop=NA, stage=NA, date=NA))
}


fExportSynthesis<-function() {
  alldf<-mExportDataFrame()
  synthesis<-aggregate(list(maxLAI=alldf$sLAI, maxRootDepth=alldf$sRootFrontDepth,  yield=alldf$sAccumulatedGrainDryMatter, harvestDate=alldf$iDate),
            by=alldf[,c("case", "sLastSowing", "sLastHarvest", "sCropCult")],
            max)
  synthesis<-synthesis[order(synthesis$harvestDate),]
  synthesis<-synthesis[synthesis$sLastHarvest<synthesis$sLastSowing,]
  return(synthesis[,c("case", "harvestDate", "sCropCult", "maxLAI", "maxRootDepth", "yield")])
}







##### PlantNitrogen 

# ---- function which returns the total mobilizable N available in the plant before seed growth ----

#' Title : function which returns the total mobilizable N available in the plant before seed growth

#'
#' @param lai numeric vector of LAI values.
#' @param slns numeric vector which contains values of the specific leaf nitrogen in senesced leaves(g N m-2).
#' @param slng numeric vector which contains values of the specific leaf nitrogen in green leaves (g N m-2).
#' @param nst numeric vector which contains values of the accumulated Nitrogen in stem (g N m-1).
#' @param wst numeric vector which contains values of the cumulative stem dry matter (g m−2).
#' @param sncs numeric vector which contains values of the minimum stem N concentration(g N g−1).
#'
#' @return total mobilizable N available in the plant at the beginning of seed fill (g N m-2).
#' @export
#'
#' @examples
fComputeNAvailableatBeginningseedFill<-function(lai,slns, slng, nst, wst, sncs){
  
  return (lai * (slng - slns)+(nst-wst*sncs))
  # Equation 17.4 on the PDF, p228
}

# ---- function which returns the proportion of the daily N transfer from the leaves ------

#' Title : function which returns the proportion of the daily N transfer from the leaves 
#'
#' @param lai numeric vector of LAI values.
#' @param slns vector which contains values of the specific leaf nitrogen in senesced leaves(g N m-2).
#' @param sncs vector which contains values of the minimum stem N concentration (g N g−1).
#' @param TRLN vector calculated with fComputeNAvailableatBeginningseedFill.
#'
#' @return vector of the same length as lai which returns the the proportion of the daily N transfer from the leaves.
#' @export
#'
#' @examples 
#' 
fComputeDailyNTransferFromleaves <- function(lai, slng, sncs, TRLN){
  return (lai * (slng-sncs)/TRLN)
  # Equation 17.5 on the PDF, p228
}



# ---- function which returns the estimate of supply vegs -------

fEstimateOfSupplyVegs <- function(cBSGMobilizable,sBdFromSowingToTerminationLeaf,sBdFromSowingToSeedGrowth, bd,cDailySeedWeightIncrease,cUptakeNGrain,pGrainMinConcentrationN,pGrainMaxConcentrationN, cDemandNAccumulation){
  ## bd not defined in all-variables, but calculated previously : bd = ppfun*verfun*tempfun
  cEstimateSupplyVeg <- cBSGMobilizable/(sBdFromSowingToTerminationLeaf-sBdFromSowingToSeedGrowth)*bd
  SeedGrowthCond <- (cDailySeedWeightIncrease == 0)
  cEstimateSupplyVeg[SeedGrowthCond] <- 0
  cDailySeedsNDemands <- pmax(cDailySeedWeightIncrease*pGrainMinConcentrationN,pmin(cEstimateSupplyVeg + cDemandNAccumulation*cUptakeNGrain,cDailySeedWeightIncrease*pGrainMaxConcentrationN))
  
  ###   If INGRN < (SGR * GNCmin) Then
  ###     INGRN = SGR * GNCmin
  ###   ElseIf INGRN >= (SGR * GNCmax) Then
  ###     INGRN = SGR * GNCmax
  
  cEstimateSupplyVeg <- cDailySeedsNDemands - cDemandNAccumulation
  return (cEstimateSupplyVeg) 
}  


# ---- function which returns the Daily demand for N accumulation when the cumulative biological days or less than the biological day before N fixation----


fDailyNDemandBeforNFixation <- function(cDemandNAccumulation ,sTotalAvailableUptakeN){
  return (pmin(cDemandNAccumulation, sTotalAvailableUptakeN))
  # If sBiologicalDaysSinceSowing < sBdFromSowingToFixation , the Daily demand for N accumulation is limited by sTotalAvailableUptakeN)
  #----------------Filtre à appliquer dans le Excel--------------- #
  
  # DailyNDemandBeforNFixation.filter is.before('EMR',3,5)
}


# ---- function which occurs when the cumulative biological days or less the the date of sowing or larger than the date of termination seed growth ---------------

#' Title function which occurs when the cumulative biological days or less the the date of sowing or larger than the date of termination seed growth
#'
#' @param sAccumulatedStemDryMatter 
#'
#' @return 6 numeric vectors of sAccumulatedStemDryMatter length with 0 values
#' @export
#'
#' @examples
fBeforeSowingOrAfterTerminationLeafGrowth <- function(sAccumulatedStemDryMatter){
  cDemandNAccumulation <- numeric(length(sAccumulatedStemDryMatter))
  sDailyRateNfromLeave <- numeric(length(sAccumulatedStemDryMatter))
  sMobilizedFromStemsN <- numeric(length(sAccumulatedStemDryMatter))
  sDailyAccumulationLeavesN <- numeric(length(sAccumulatedStemDryMatter))
  sDailyAccumulationStemN <- numeric(length(sAccumulatedStemDryMatter))
  cDailySeedsNDemands <- numeric(length(sAccumulatedStemDryMatter))
  return (list(val1 = cDemandNAccumulation, val2 = sDailyRateNfromLeave, val3 = sMobilizedFromStemsN, val4 = sDailyAccumulationLeavesN, val5 = sDailyAccumulationStemN, val6 = cDailySeedsNDemands))
  # There is no nitrogen exchange between the stem and the leaves if it is before sowing or after the growth phase of the seeds
  #----------------Filtre à appliquer dans le Excel--------------- #
  
  # BeforeSowingOrAfterTerminationLeafGrowth.filter is.before('SOW',0) & is.after('R7',0) 
}
 

# ---- function which occurs when BNF (Biological at beginning of N Fixation) is greater than BSG (Biological day before seed growth)


fDemandNAccumulationWhenBNFHigherBSG <- function(cDemandNAccumulation, sTotalAvailableUptakeN){
  return (pmax(cDemandNAccumulation,sTotalAvailableUptakeN))
  # for non legum
  # Function which occurs if BNF > BSG in a non-legum case
  
}

#-------------------- function which occurs when the cumulative biological days or less the the date of sowing or larger than the date of termination seed growth ---------------

BeforeSowingOrAfterTerminationLeafGrowth <- function(cDemandNAccumulation, sDailyRateNFromLeave, sDailyRateNFromStem, sDailyAccumulationleavesN, sDailyAccumulationStemN, cDailySeedsNDemands){
  cDemandNAccumulation <- numeric(lenght(cDemandNAccumulation))
  sDailyRateNfromLeave <- numeric(lenght(sDailyRateNfromLeave))
  sDailyRateNFromStem <- numeric(lenght(sDailyRateNFromStem))
  sDailyAccumulationLeavesN <- numeric(lenght(sDailyAccumulationLeavesN))
  sDailyAccumulationStemN <- numeric(lenght(sDailyAccumulationStemN))
  cDailySeedsNDemends <- numeric(lenght(cDailySeedsNDemends))
  # There is no nitrogen exchange between the stem and the leaves if it is before sowing or after the growth phase of the seeds
  #----------------Filtre à appliquer dans le Excel--------------- #
  
  #BeforeSowingOrAfterTerminationLeafGrowth.filter is.before('EMR',0) & is.after('R7',0)
}


#---------------------- function which returns the Daily demand for N accumulation when the cumulative biological days or less than the biological day before N fixation--------------------



fDailyNDemandBeforNFixation <- function(cDemandNAccumulation ,sTotalAvailableUptakeN){
  return (pmin(cDemandNAccumulation, sTotalAvailableUptakeN))
  # If sBiologicalDaysSinceSowing < sBdFromSowingToFixation , the Daily demand for N accumulation is limited by sTotalAvailableUptakeN)
  #----------------Filtre à appliquer dans le Excel--------------- #
  
  # DailyNDemandBeforNFixation.filter is.before('EMR',3,5) 
}






# ---- function which apply during Vegetative Growth, which means between phase BNF (EMR + 3,5) and (R5) -----

#' Title function which apply during Vegetative Growth, which means between phase BNF (EMR + 3,5) and (R5)
#'

#' @param pSpecLeafNSenescenceLeaf (SLNS) : numeric vector which contains values of specific leaf nitrogen in senesced leaves (minimum)
#' @param pSpecLeafNGreenLeaf (SLNG) : numeric vector which contains values of the specific leaf nitrogen in green leaves (g N m-2).
#' @param pStemMinimumNconcentration (SNCS) : numeric vector which contains values of the minimum stem N concentration (g N g−1).
#' @param pContentStemN (SNCG) : numeric vector which contains N content per unit stem weight (g N g-1).
#' @param pNUPmax  (MXNUP) : numeric vector which contains values of NUP maximum rate (g N m-2 d-1)
#' @param cDailyStemWeightIncrease (GST) : numeric vector which contains values of Daily increase in stem mass (g m−2 day−1 )
#' @param cFTSWRrootZone (FTSWRZ) : numeric vector which contains values of the FTSW in the root zone ([0,1])
#' @param sAccumulatedStemDryMatter (WST) : numeric vector which contains values of the cumulative stem dry matter (g m-2)
#' @param sTotalAvailableUptakeN (SNAVL) : numeric vector which contains values of the Total amount of N that is accessible to plant for uptake in the soil (sum of each layer)(g m-2)
#' @param sAccumulatedVegetativeDryMatter (WVEG) : numeric vector which contains values of cumulative vegetative organs dry matter (g m−2 )
#' @param sLAI (LAI) : numeric vector which contains values of Leaf area index (m2 m-2)

#'
#' @return 4 numeric vectors which contains values of the accumulated nitrgen in stem, the accumulated nitrogen in leaves, the total accumulated nitrogen in stem and leaves and the accumulated nitrogen in grain (g N m-2)
#' @export
#'
#' @examples 
fNFixationDuringVegetativeGrowth <- function(sAccumulatedStemDryMatter, pContentStemN, cGrowthLAI, pSpecLeafNGreenLeaf, pNUPmax, sTotalAvailableUptakeN,cDailyStemWeightIncrease, sAccumulatedVegetativeDryMatter,cFTSWRrootZone,pStemMinimumNconcentration, sLAI, pSpecLeafNSenescenceLeaf){
  
  WSXF <- c(1,1,1)
  # Waiting to have more information about WSXF (ICICICICICICI)
  sNitrogenAccumulation <- rep(1,length(sAccumulatedStemDryMatter))
  # Value initialized at 1 outside the function, don't know why this because used in a multiplication
  sAccumulatedLeafNitrogen <- sLAI*pSpecLeafNGreenLeaf
  # Initialization of NLF : NLF <- LAI * SLNG
  sAccumulatedNStem <- sAccumulatedStemDryMatter * pContentStemN
  # Initialization of NST : NST <- WST * SNCG
  sAccumulatedNGrain <- numeric(length(sAccumulatedStemDryMatter))
  # Initialization of NGRN : Vector of 0 of the length of sAccumulatedStemDryMatter
  cCoefBiologicalNFixation <- c(1,1,1)
  # Arbitrary initialization of NFC cCoefBiologicalNFixation : Not done in the VBA code (ICICICICICICIC)
  
  cDailySeedsNDemands <- numeric(length(sAccumulatedStemDryMatter))
  cDemandResultDeficiencies <- pmax((sAccumulatedStemDryMatter * pContentStemN) - sAccumulatedNStem, 0)
  cDemandNAccumulation <- pmin((cDailyStemWeightIncrease * pContentStemN) + (cGrowthLAI * pSpecLeafNGreenLeaf) + cDemandResultDeficiencies, pNUPmax)
  cCoefBiologicalNFixation <- cCoefBiologicalNFixation*(3/4) + (cDemandNAccumulation/sAccumulatedVegetativeDryMatter)*(1/4) ### ICICICIICICIC pas de sens physique à cette équation
  ### 3/4 and 1/4 seem to be like ponderation coefficients
  cDemandNAccumulation <- pmax(cDemandNAccumulation*sNitrogenAccumulation, 0) 
  
  
  ConditionFTSWRZ <- cFTSWRrootZone > 1
  cDemandNAccumulation[ConditionFTSWRZ] <- cDemandNAccumulation[ConditionFTSWRZ]*WSXF[ConditionFTSWRZ]
  
  
  ConditionDDMP <- cDryMatterProduction == 0
  cDemandNAccumulation[ConditionDDMP] <- 0
  
  cDemandNAccumulation <- pmin(cDemandNAccumulation,sTotalAvailableUptakeN)
  
  
  ## cBiologicalNFixation : BNF
  
  cCoefBiologicalNFixation <- numeric(length(sAccumulatedStemDryMatter))
  cBiologicalNFixation <- numeric(length(sAccumulatedStemDryMatter))
  LimitationCropUptake <- cDemandNAccumulation > sTotalAvailableUptakeN
  # Condition 
  cBiologicalNFixation[LimitationCropUptake] <- pmax(cDemandNAccumulation[LimitationCropUptake]-sTotalAvailableUptakeN[sTotalAvailableUptakeN],0)
  
 

  sCumulativeNFixation <- sCumulativeNFixation + cBiologicalNFixation
  ## sCumulativeNFixation : CUMBNF
  # Variable updated at each time step 
  
  
  
  # ------------------------- Beginning of translation of the Diagramm of the PDF which describes the repartition of nitrogen exchanges during seed growth ------------------- #
  
  
  
  
  
  ## Initialisation for the calcul of the 4 principal variables : 
  
  sDailyAccumulationStemN <- sDailyRateNFromStem <- sDailyAccumulationLeavesN <- sDailyRateNfromLeave <- numeric(length(sAccumulatedStemDryMatter))
  
  # sDailyAccumulationStemN : Daily rate of nitrogen accumulation in stems (INST)
  # sDailyAccumulationLeavesN : Daily rate of nitrogen accumulation in leaves (INLF)
  # sDailyRateNFromLeave : Daily rate of nitrogen mobilized from leaves (XNLF)
  # sDailyRateNFromStem : Daily rate of nitrogen mobilized from stems (XNST)
  
  
  
  
  StemDryMatterCondition <- sAccumulatedNStem < sAccumulatedStemDryMatter*pStemMinimumNconcentration
  
  # StemDryMatterCondition = First Condition : NST < WST * SNCS
  
  sDailyAccumulationLeavesN[!StemDryMatterCondition] <- cGrowthLAI[!StemDryMatterCondition]*pSpecLeafNGreenLeaf[!StemDryMatterCondition]
  sDailyAccumulationStemN [StemDryMatterCondition] <- sAccumulatedStemDryMatter[StemDryMatterCondition]*pStemMinimumNconcentration[StemDryMatterCondition]-sAccumulatedNStem[StemDryMatterCondition]
  
  # NLeafGreaterThanNNeeded = 2nd Condition : INLF > NUP and the first condition is not satisfied
  # NLeafSmallerThanNNeeded = 3nd Condition : INLF < NUP and the first condition is not satisfied
  
  NLeafGreaterThanNNeeded <- !StemDryMatterCondition & sDailyAccumulationLeavesN > cDemandNAccumulation
  NLeafSmallerThanNNeeded <- !StemDryMatterCondition & sDailyAccumulationLeavesN <=cDemandNAccumulation
  sDailyAccumulationLeavesN [NLeafGreaterThanNNeeded]<- cDemandNAccumulation[NLeafGreaterThanNNeeded] + sDailyRateNFromStem[NLeafGreaterThanNNeeded]
  
  sDailyAccumulationStemN [NLeafSmallerThanNNeeded] <- cDemandNAccumulation[NLeafSmallerThanNNeeded]-sDailyAccumulationLeavesN [NLeafSmallerThanNNeeded]
  sDailyRateNFromStem[NLeafGreaterThanNNeeded] <- min(sDailyAccumulationLeavesN  - cDemandNAccumulation, sAccumulatedNStem - sAccumulatedStemDryMatter * pStemMinimumNconcentration)[NLeafGreaterThanNNeeded]
  
  # NStemGreaterThanNNeeded = 4th condition : INST > NUP and the first condition is satisfied
  # NStemSmallerThanNNeeded = 5th condition : INST < NUP and the first condition is satisfied
  
  NStemGreaterThanNNeeded <- StemDryMatterCondition & sDailyAccumulationStemN >cDemandNAccumulation
  NStemSmallerThanNNeeded <- StemDryMatterCondition & sDailyAccumulationStemN <=cDemandNAccumulation
  sDailyAccumulationLeavesN [NStemSmallerThanNNeeded ]<-min(cGrowthLAI*pSpecLeafNGreenLeaf, cDemandNAccumulation-sDailyAccumulationStemN )[NStemSmallerThanNNeeded ]
  sDailyRateNfromLeave[NStemGreaterThanNNeeded ]<-(sDailyAccumulationStemN -cDemandNAccumulation)[NStemGreaterThanNNeeded ]
  sDailyAccumulationStemN [NStemSmallerThanNNeeded ]<-(cDemandNAccumulation-sDailyAccumulationLeavesN )[NStemSmallerThanNNeeded ]
  
  
  #--------- Computation of Daily rate of nitrogen mobilized from stems --------- #
  
  cBSGMobilizable <- sLAI*(pSpecLeafNGreenLeaf-pSpecLeafNSenescenceLeaf) + (sAccumulatedNStem-sAccumulatedStemDryMatter*pStemMinimumNconcentration)
  
  ## cBSGMobilizable : TRLNBSG, Total mobilizable N available in the plant before seed growth  
  
  
  
  
  
  sAccumulatedNStem <- sAccumulatedNStem + sDailyAccumulationStemN - sDailyRateNFromStem
  # sAccumulatedNStem = NST & sDailyAccumulationStemN = INST
  # Accumulated Nitrogen in Stems
  sAccumulatedLeafNitrogen <- sAccumulatedLeafNitrogen + sDailyAccumulationLeavesN - sDailyRateNfromLeave
  # Accumulated Nitrogen in leaves
  cTotalAccumulatedNitrogen <- sAccumulatedNStem + sAccumulatedLeafNitrogen
  # Total Accumulated Nitrogen
  sAccumulatedNGrain <- sAccumulatedNGrain + cDailySeedsNDemands
  # Accumulated Nitrogen in Grain, variable not initialized in the source code, initialized here at 0
  # The Value of this variable doesn't change during this phase because the value of cDailySeedsNDemands is never updated
  
  return (list(val1 = sAccumulatedNStem, val2 = sAccumulatedLeafNitrogen, val3 = cTotalAccumulatedNitrogen, val4 = sAccumulatedNGrain, val5 = sCumulativeNFixation, val6 = cBSGMobilizable))
       
             #----------------Filtre à appliquer dans le Excel--------------- #
          
             # NFixationDuringVegetativeGrowth.filter is.after('EMR', 3.5) & is.before('R5')       
}

  
#---------------------- Function which occurs during seed growth, which means between phase R5 and R7 ---------------------#

#' Title function which returns the accumulated nitrogen in the stem, leaves and grain each day

#' @param pStemMinimumNconcentration (SNCS) : numeric vector which contains values of the minimum stem N concentration (g N g−1).
#' @param pGrainConversionCoefficient (GCC) : numeric vector which contains values of ratio of energy content of vegetative tissues to that of grain (g g−1 )
#' @param pContentStemN (SNCG) : numeric vector which contains N content per unit stem weight (g N g-1).
#' @param pSpecLeafNGreenLeaf (SLNG) : numeric vector which contains values of the specific leaf nitrogen in green leaves (g N m-2).
#' @param pGrainMaxConcentrationN (GNCmax) : numeric vector which contains valuesof grain max N concentration (g N g-1)
#' @param pGrainMinConcentrationN (GNCmin) : numeric vector which contains values of grain min N Concentration (g N g-1)
#' @param pNUPmax (MXNUP) : numeric vector which contains values of NUP maximum rate (g N m-2 d-1)
#' @param cGrowthLAI (GLAI) : numeric vector which contains values of the Daily increase (growth) in leaf area index (m2 m-2 d-1)
#' @param cDailySeedWeightIncrease (SGR) : numeric vector which contains values of the daily seed growth (g m−2 day−1)
#' @param cCoefBiologicalNFixation (NFC) : numeric vector which contains values of coefficient of biological nitrogen fixation per unit mass
#' @param cCoefWaterStressSaturation (WSXF) : numeric vector which contains values of Water Stress from soil saturation ([0,1])
#' @param cDailyStemWeightIncrease (GST) : numeric vector which contains values of Daily increase in stem mass (g m−2 day−1 )
#' @param cDryMatterProduction (DDMP) : numeric vector which contains values of Daily dry matter production (g m-2 d-1)
#' @param cFTSWrootZone (FTSWRZ) : numeric vector which contains values of the FTSW in the root zone ([0,1])
#' @param sTotalAvailableUptakeN (SNAVL) : numeric vector which contains values of the Total amount of N that is accessible to plant for uptake in the soil (sum of each layer)(g m-2)
#' @param sAccumulatedStemDryMatter (WST) : numeric vector which contains values of the cumulative stem dry matter (g m-2)
#' @param sLAI (LAI) : numeric vector which contains values of Leaf area index (m2 m-2)
#' @param sAccumulatedVegetativeDryMatter (WVEG) : numeric vector which contains values of cumulative vegetative organs dry matter (g m−2 )
#'
#' @return 4 numeric vectors which contains values of the accumulated nitrgen in stem, the accumulated nitrogen in leaves, the total accumulated nitrogen in stem and leaves and the accumulated nitrogen in grain (g N m-2)
#' @export
#'
#' @examples

fNFixationDuringSeedGrowth <- function(cDailySeedWeightIncrease, pGrainMaxConcentrationN,pContentStemN, cGrowthLAI, pSpecLeafNGreenLeaf, pNUPmax, cCoefBiologicalNFixation,sAccumulatedVegetativeDryMatter,cCoefWaterStressSaturation,cDailyStemWeightIncrease,cDryMatterProduction,pGrainConversionCoefficient,cFTSWrootZone,sTotalAvailableUptakeN,sAccumulatedStemDryMatter,pGrainMinConcentrationN,sLAI,pStemMinimumNconcentration){
  
  sCumulativeNFixation <- numeric(length(cDailySeedWeightIncrease))
  # Initialization of the cumulative 
  sNitrogenAccumulation <- rep(1,length(cDailySeedWeightIncrease))
  # WSFN = 1 in the VBA code, but no explanations and only used in water-stress factors
  sAccumulatedLeafNitrogen <- sLAI*pSpecLeafNGreenLeaf
  # Initialization of NLF : NLF <- LAI * SLNG
  sAccumulatedNStem <- sAccumulatedStemDryMatter * pContentStemN
  # Initialization of NST : NST <- WST * SNCG
  sAccumulatedNGrain <- numeric(length(sAccumulatedStemDryMatter))
  # Initialization of NGRN : Vector of 0 of the length of sAccumulatedStemDryMatter
  
  
  
  cDailySeedsNDemands <- cDailySeedWeightIncrease*pGrainMaxConcentrationN
  # cDailySeedWeightIncrease : SGR, daily seed growth 
  # First estimate using maximum GNC, maybe we could have tried to use minimum GNC sDailyAccumulationStemN ead, the pdf has a single constant value for GNC
  cDemandNAccumulation <- pmin(pmax(cDailySeedsNDemands + (cDailyStemWeightIncrease * pContentStemN) + (cGrowthLAI * pSpecLeafNGreenLeaf),0),pNUPmax)
  # Daily demand for N accumulation can't be negative and is limited to a maximum.
  # cDailyStemWeightIncrease (GST) : cDailyStemWeightIncrease
  cUptakeNGrain <- cDailySeedsNDemands / (cDemandNAccumulation + 0.00000001)
  # No really information about the variable cUptakeNGrain (cDemandNAccumulation_fr_grn) in the book, not defined
  # No idea of the mean of the value 0.00000001
  
  #fBeforeNFixationOrNonLegum <- function(cRateBiologicalNFix){
  #cRateBiologicalNFix <- numeric(length(cRateBiologicalNFix))
  # before BNF activation OR for non-legum crops
  # DNF :cRateBiologicalNFix, Actual rate of biological nitrogen fixation
  # Fonction which occurs beforce N Fixation
  # }
  
  # ElseIf CBD >= bdBNF in the VBA version, but we already are in that case
  
  sPotentielRateNitrogenFixation <- pmin(cCoefBiologicalNFixation * sAccumulatedVegetativeDryMatter, cDemandNAccumulation)
  # No value initialized for NFC (cCoefBiologicalNFixation) in the VBA code
  # PDNF : Potential rate of biological nitrogen fixation, which is limited to the daily demand for N accumulation
  # for legum
  cRateBiologicalNFix <- sPotentielRateNitrogenFixation * sNitrogenAccumulation 
  #for legum
  
  DryMatterCondition <- (cDryMatterProduction <= cDailySeedWeightIncrease*pGrainConversionCoefficient | cDryMatterProduction == 0)
  cRateBiologicalNFix[DryMatterCondition] <- 0
  # For Legum
  
  
  ConditionFTSWRZ <- cFTSWrootZone > 1
  cDemandNAccumulation[ConditionFTSWRZ]<- cDemandNAccumulation[ConditionFTSWRZ]*cCoefWaterStressSaturation[ConditionFTSWRZ]
  
  
  SeedGrowthCondition <- cDryMatterProduction < cDailySeedWeightIncrease/pGrainConversionCoefficient
  cDemandNAccumulation[DryMatterCondition] <- 0
  ## cDemandNAccumulation is set equal to 0 when daily dry matter production (DDMP) by the crop does not exceed SGR (Daily Seed Growth)
  
  
  #---------------------------------------------------------------------------------------------------------------------------------------------------
  
  cDemandNAccumulation <- pmin(cDemandNAccumulation,sTotalAvailableUptakeN + cRateBiologicalNFix)
  cBiologicalNFixation <- pmax(cDemandNAccumulation - sTotalAvailableUptakeN, 0)
  sCumulativeNFixation <- sCumulativeNFixation + cBiologicalNFixation
  
  
  
  #----------------- Computation of the Nitrogen dispersal in leaves and stems during the vegetative Growth ------------- #
  
  
  ## Initialisation at 0 for the calcul of the 4 principal variables : 
  
  sDailyAccumulationStemN <- sDailyRateNFromStem <- sDailyAccumulationLeavesN <- sDailyRateNfromLeave <- numeric(length(sAccumulatedStemDryMatter))
  
  # INST = XNST = INLF = XNLF = 0
  
  NUP2 <- cDemandNAccumulation - cDailySeedWeightIncrease*(pGrainMinConcentrationN+pGrainMaxConcentrationN)/2
  # The demand in Nitrogen seems to be adjusted in that case (NUP2 is the adjusted value)
  
  # ICICICICI : the code source uses a GNC value which is not used in the book or in the excel, i chose to use the mean between GNCmin and GNCmax to replace this value.
  
  GrainCondition <-  cDemandNAccumulation > cDailySeedsNDemands
  
  # First condition : NUP > INGRN
  
  # If this first condition is not satisfied : 
  
  sDailyAccumulationLeavesN[!GrainCondition] <- 0
  sDailyAccumulationStemN[!GrainCondition] <- 0
  sDailyRateNfromLeave[!GrainCondition] <- (cDailySeedsNDemands- cDemandNAccumulation)*FXLF
  sDailyRateNFromStem[!GrainCondition] <- (cDailySeedsNDemands -  cDemandNAccumulation)*(1 - FXLF)
  
  # FXLF : proportion of the daily N transfer from the leaves
  # FXLF is calculated thanks to another function below
  
  StemDryMatterCondition <- (GrainCondition) & (sDailyAccumulationStemN <= sAccumulatedStemDryMatter*pStemMinimumNconcentration )
  NoStemDryMatterCondition <- (GrainCondition) & (sDailyAccumulationStemN > sAccumulatedStemDryMatter*pStemMinimumNconcentration )
  
  # StemDryMatterCondition = 2nd condition : first condition is satisfied and NST <= WST * SNCS
  # NoStemDryMatterCondition = 3rd condition : first condition is satisfied and NST > WST * SNCS
  
  sDailyAccumulationStemN[StemDryMatterCondition] <- sAccumulatedStemDryMatter[StemDryMatterCondition] * pStemMinimumNconcentration [StemDryMatterCondition] - sDailyAccumulationStemN[StemDryMatterCondition]
  sDailyRateNFromStem[StemDryMatterCondition] <- 0 ### not necessary, just to be clear
  sDailyAccumulationLeavesN[NoStemDryMatterCondition] <- cGrowthLAI[NoStemDryMatterCondition]*pSpecLeafNGreenLeaf[NoStemDryMatterCondition]
  sDailyRateNfromLeave[NoStemDryMatterCondition] <- 0 #### Not necessary, just to be clear
  
  NStemGreaterThanNNeeded <-StemDryMatterCondition &  sDailyAccumulationStemN >= NUP2
  NStemSmallerThanNNeeded <- StemDryMatterCondition &  sDailyAccumulationStemN < NUP2
  
  # NStemGreaterThanNNeeded = 4th condition : 2nd condition is satisfied and INST >= NUP2
  # NStemSmallerThanNNeeded = 5th condition : 2nd condition is satisfied and INST < NUP2
  
  sDailyRateNfromLeave[ NStemGreaterThanNNeeded] <-  sDailyAccumulationStemN[ NStemGreaterThanNNeeded] - NUP2[ NStemGreaterThanNNeeded]
  sDailyAccumulationLeavesN[ NStemGreaterThanNNeeded] <- 0 #### Not necessary, just to be clear
  sDailyAccumulationLeavesN[ NStemSmallerThanNNeeded] <- (pmin(cGrowthLAI*pSpecLeafNGreenLeaf, NUP2- sDailyAccumulationStemN))[ NStemSmallerThanNNeeded]
  sDailyRateNfromLeave[ NStemSmallerThanNNeeded] <- 0 #### Not necessary, just to be clear
  
  NLeafGreaterThanNeeded <- NoStemDryMatterCondition &  sDailyAccumulationLeavesN >= NUP2
  NLeafSmallerThanNeeded <- NoStemDryMatterCondition &  sDailyAccumulationLeavesN < NUP2
  
  # NLeafGreaterThanNeeded = 6th condition : 2nd condition is unsatisfied and INLF >= NUP2
  # NLeafSmallerThanNeeded = 7th condition : 2nd condition is unsatisfied and INLF < NUP2
  
  sDailyAccumulationStemN[NLeafGreaterThanNeeded] <- 0 #### Not necessary, just to be clear
  sDailyRateNFromStem[NLeafGreaterThanNeeded] <-(pmin( sDailyAccumulationLeavesN - NUP2, sDailyAccumulationStemN - sAccumulatedStemDryMatter*pStemMinimumNconcentration ))[NLeafGreaterThanNeeded]
  sDailyAccumulationLeavesN[NLeafGreaterThanNeeded] <- NUP2[ NLeafGreaterThanNeeded] + sDailyRateNFromStem[ NLeafGreaterThanNeeded]
  sDailyAccumulationStemN[NLeafSmallerThanNeeded] <- NUP2[ NLeafSmallerThanNeeded] +  sDailyAccumulationLeavesN[ NLeafSmallerThanNeeded]
  
  
  # ------------------------------------------ end of computation -----------------------
  
  
  sAccumulatedNStem <- sAccumulatedNStem + sDailyAccumulationStemN - sDailyRateNFromStem
  # sAccumulatedNStem = NST & sDailyAccumulationStemN = INST
  # Accumulated Nitrogen in Stems
  sAccumulatedLeafNitrogen <- sAccumulatedLeafNitrogen + sDailyAccumulationLeavesN - sDailyRateNfromLeave
  # Accumulated Nitrogen in leaves
  cTotalAccumulatedNitrogen <- sAccumulatedNStem + sAccumulatedLeafNitrogen
  # Total Accumulated Nitrogen
  sAccumulatedNGrain <- sAccumulatedNGrain + cDailySeedsNDemands
  # Accumulated Nitrogen in Grain, variable not initialized in the source code, initialized here at 0
  
  
  
  return (data.frame(val1 = sAccumulatedNStem ,val2 = sAccumulatedLeafNitrogen,val3 = cTotalAccumulatedNitrogen,val4 = sAccumulatedNGrain))
}



rUpdatePlantNitrogen <-function() {
    
  # Listing of all parameters needed 
    
  SGR <- ALLDAYDATA$cDailySeedWeightIncrease # to get SGR
  SNCS <-ALLDAYDATA$pStemMinimumNconcentration # to get SNCS
  SLNG <- ALLDAYDATA$pSpecLeafNGreenLeaf # to get SNLG
  LAI <- ALLDAYDATA$sLAI # to get LAI
  NST <- ALLDAYDATA$sNstem # to get NST
  WST <- ALLDAYDATA$sAccumulatedStemDryMatter # to get WST
  GCC <- ALLDAYDATA$pGrainConversionCoefficient # to get GCC
  SNCG <- ALLDAYDATA$pContentStemN # to get SNCG
  GNCmax <- ALLDAYDATA$pGrainMaxConcentrationN # to get GNCmax
  GNCmin <- ALLDAYDATA$pGrainMinConcentrationN # to get GNCmin
  MXNUP <- ALLDAYDATA$pNUPmax # to get MXNUP
  GLAI <- ALLDAYDATA$cGrowthLAI # to get GLAI
  NFC <- ALLDAYDATA$cCoefBiologicalNFixation # to get NFC
  WSXF <- ALLDAYDATA$cCoefWaterStressSaturation # to get WSXF
  GST <- ALLDAYDATA$cDailyStemWeightIncrease # to get GST
  DDMP <- ALLDAYDATA$cDryMatterProduction # to get DDMP
  FTSWRZ <- ALLDAYDATA$cFTSWrootZone # to get FTSWRZ
  SNAVL <- ALLDAYDATA$sTotalAvailableUptakeN # to get SNAVL 
  WST <- ALLDAYDATA$sAccumulatedStemDryMatter # to get WST
  WVEG <- ALLDAYDATA$sAccumulatedVegetativeDryMatter # to get WVEG
  
  
  # Creation of the filters 
  
  VegetativeGrowthFilter <- applyfilters(VegetativeGrowthPhase)
  SeedGrowthFilter <- applyfilters(SeedGrowthPhase)
  
  # Application of filters
  
  resultat[VegetativeGrowthFilter] <- fNFixationDuringVegetativeGrowth(cDailySeedWeightIncrease = SGR,pGrainMaxConcentrationN = GNCmax,pContentStemN = SNCG,cGrowthLAI = GLAI,pSpecLeafNGreenLeaf = SLNG,pNUPmax = MXNUP,cCoefBiologicalNFixation = NFC ,sAccumulatedVegetativeDryMatter = WVEG,cCoefWaterStressSaturation = WSXF,cDailyStemWeightIncrease = GST,cDryMatterProduction = DDMP,pGrainConversionCoefficient = GCC,cFTSWrootZone = FTSWRZ,sTotalAvailableUptakeN = SNAVL,sAccumulatedStemDryMatter = WST,pGrainMinConcentrationN = GNCmin,sLAI = LAI, pStemMinimumNconcentration = SNCS)[VegetativeGrowthFilter]
  resultat[SeedGrowthFilter] <- fNFixationDuringSeedGrowth(cDailySeedWeightIncrease = SGR, pGrainMaxConcentrationN  = GNCmax, pContentStemN = SNCG, cGrowthLAI = GLAI, pSpecLeafNGreenLeaf = SLNG, pNUPmax = MXNUP, cCoefBiologicalNFixation = NFC, sAccumulatedVegetativeDryMatter = WVEG, cCoefWaterStressSaturation = WSXF, cDailyStemWeightIncrease = GST, cDryMatterProduction = DDMP, pGrainConversionCoefficient = GCC, cFTSWrootZone = FTWSRZ, sTotalAvailableUptakeN = SNAVL, sAccumulatedStemDryMatter = WST, pGrainMinConcentrationN = GNCmin, sLAI = LAI, pStemMinimumNconcentration = SNCS)[SeedGrowthFilter]
}



